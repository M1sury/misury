<html>
  <head>
    <meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>SpringBoot笔记 | MyBlog</title>
<link rel="shortcut icon" href="https://m1sury.github.io/favicon.ico?v=1625411223477">
<link href="https://cdn.jsdelivr.net/npm/remixicon@2.3.0/fonts/remixicon.css" rel="stylesheet">
<link rel="stylesheet" href="https://m1sury.github.io/styles/main.css">
<link rel="alternate" type="application/atom+xml" title="SpringBoot笔记 | MyBlog - Atom Feed" href="https://m1sury.github.io/atom.xml">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Droid+Serif:400,700">



    <meta name="description" content="SpringBoot
[toc]
什么是Spring
Spring是一个开源框架，2003年兴起的一个轻量级的Java开发框架，作者：Rod Jonhson。
Spring是为了解决企业级应用开发的复杂性而创建的，简化开发
Spring如何..." />
    <meta name="keywords" content="" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
    <script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
  </head>
  <body>
    <div class="main">
      <div class="main-content">
        <div class="site-header">
  <a href="https://m1sury.github.io">
  <img class="avatar" src="https://m1sury.github.io/images/avatar.png?v=1625411223477" alt="">
  </a>
  <h1 class="site-title">
    MyBlog
  </h1>
  <p class="site-description">
    不要总问低级的问题,独立思考
  </p>
  <div class="menu-container">
    
      
        <a href="/misury" class="menu">
          首页
        </a>
      
    
      
        <a href="/archives" class="menu">
          归档
        </a>
      
    
      
        <a href="/tags" class="menu">
          标签
        </a>
      
    
      
        <a href="/post/about" class="menu">
          关于
        </a>
      
    
  </div>
  <div class="social-container">
    
      
        <a href="https://github.com/M1sury" target="_blank">
          <i class="ri-github-line"></i>
        </a>
      
    
      
    
      
    
      
    
      
    
  </div>
</div>

        <div class="post-detail">
          <article class="post">
            <h2 class="post-title">
              SpringBoot笔记
            </h2>
            <div class="post-info">
              <span>
                2021-07-04
              </span>
              <span>
                71 min read
              </span>
              
            </div>
            
            <div class="post-content-wrapper">
              <div class="post-content">
                <h2 id="springboot">SpringBoot</h2>
<p>[toc]</p>
<h3 id="什么是spring">什么是Spring</h3>
<p>Spring是一个开源框架，2003年兴起的一个轻量级的Java开发框架，作者：<code>Rod Jonhson</code>。</p>
<p><strong>Spring是为了解决企业级应用开发的复杂性而创建的，简化开发</strong></p>
<h4 id="spring如何简化开发">Spring如何简化开发</h4>
<p>采用四种关键策略：</p>
<ol>
<li>基于POJO的轻量级和最小侵入性编程；</li>
<li>通过IOC，依赖注入(DI)和面向接口实现低耦合</li>
<li>基于切面(AOP)和惯例进行声明式编程</li>
<li>通过切面和模板减少样式代码</li>
</ol>
<h3 id="什么是springboot">什么是SpringBoot</h3>
<p>SpringBoot是基于Spring开发的项目的起点，SpringBoot的设计是<strong>为了简化开发，减少配置文件</strong></p>
<p>Spring本身不提供Spring框架的核心特性以及扩展功能，只是用于快速、敏捷的开发新一代基于Spring框架的应用程序。SpringBoot以<strong>约定大于配置</strong>的核心思想，默认进行了很多配置，</p>
<h5 id="springboot的优点">SpringBoot的优点</h5>
<ul>
<li>为了让Spring开发者更快的入门</li>
<li><strong>开箱即用</strong>，提供各种默认配置来简化项目配置</li>
<li>内嵌式容器简化web项目</li>
<li>没有冗余代码生成和XML配置的要求</li>
</ul>
<h4 id="第一个springboot程序idea版本20203">第一个SpringBoot程序(idea版本2020.3)</h4>
<p>1、新建项目，next就可以</p>
<figure data-type="image" tabindex="1"><img src="https://gitee.com/a1021809072/mypic/raw/master/img/image-20210131122146664.png" alt="image-20210131122146664" loading="lazy"></figure>
<p>2、package的名字不需要太长,然后next</p>
<figure data-type="image" tabindex="2"><img src="https://gitee.com/a1021809072/mypic/raw/master/img/image-20210131123020239.png" alt="image-20210131123020239" loading="lazy"></figure>
<p>3、添加Web依赖</p>
<figure data-type="image" tabindex="3"><img src="https://gitee.com/a1021809072/mypic/raw/master/img/image-20210131123143829.png" alt="image-20210131123143829" loading="lazy"></figure>
<p>4、自定义项目存放的地址</p>
<figure data-type="image" tabindex="4"><img src="https://gitee.com/a1021809072/mypic/raw/master/img/image-20210131123215255.png" alt="image-20210131123215255" loading="lazy"></figure>
<p>5、写Controller层(<strong><font color=red>Application类要与Controller以及其他层的包在同级目录下</font></strong>)</p>
<pre><code class="language-java">package com.m1sury.controller;

import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.RequestMapping;

@Controller
public class HelloController {
    @RequestMapping(&quot;/hello&quot;)
    public String hello(){
        return &quot;hello&quot;;
    }
}
</code></pre>
<p>6、最后运行Application类就可以了，然后访问localhost</p>
<h5 id="font-colorred为什么springboot中controller以及其他层要与application类在同级目录下font"><font color=red>为什么SpringBoot中controller以及其他层要与Application类在同级目录下</font></h5>
<p><strong>是因为SpringBoot程序只加载Application类所在包及其子包下的内容</strong></p>
<ul>
<li>主程序所在包及其下面的所有子包里面的组件都会被默认扫描进来</li>
<li>想要改变扫描路径,<code>@SpringBootApplication(scanBasePackages=&quot;com.xx&quot;)</code>或者<code>ComponentScan(com.xx)</code>指定扫描路径</li>
</ul>
<pre><code class="language-java">@SpringBootApplication
等同于
@SpringBootConfiguration //继承@Configuration,代表当前是一个配置类
@EnableAutoConfiguration //
@ComponentScan(&quot;com.xx&quot;) //指定扫描哪些包的注解
</code></pre>
<h3 id="底层注解">底层注解</h3>
<pre><code class="language-java">@Import({User.class,DBHelper.class}) //给容器中自动创建出多个类型的组件.默认组件的名字就是全类名
@Conditional //条件装配：满足Conditional指定的条件，则进行组件注入,不成立则不注册相应的组件,Conditional中有很多子注解功能会更加细化
@ImportResource(&quot;classpath:配置文件名&quot;) //原生配置文件引入，比如beans.
</code></pre>
<h3 id="原理初探">原理初探</h3>
<p><strong>pom.xml</strong></p>
<ul>
<li>spring-boot-dependencies：核心依赖在父工程中</li>
<li>在引入springboot依赖时，不需要指定版本的原因，就是因为父依赖中的<code>spring-boot-dependencies</code>中已经指定好了版本</li>
</ul>
<p><strong>启动器</strong></p>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
<ul>
<li>启动器就是SpringBoot的启动场景</li>
<li>如果需要web环境的，就会导入<code>spring-boot-starter-web</code>的所有的依赖</li>
<li>springboot会将所有的功能场景，变成一个启动器，比如单元测试会使用<code>spring-boot-starter-test</code>依赖，web环境就使用<code>spring-boot-starter-web</code></li>
</ul>
<p><strong>Application类</strong></p>
<ul>
<li>
<p><code>@SpringBootApplication</code>：标注这个类是一个springboot的应用，启动类下的所有资源被导入</p>
</li>
<li>
<p><code>SpringApplication.run</code>：启动springboot应用</p>
</li>
<li>
<p>内置注解</p>
<ul>
<li>
<pre><code class="language-java">@SpringBootConfiguration //关于springboot的配置
	@Configuration  //spring配置类
	@Component  //spring的一个组件
        
        
@EnableAutoConfiguration //自动配置
    @AutoConfigurationPackage//自动配置包
    	@Import(AutoConfigurationPackages.Registrar.class)//自动配置(包注册)
    @Import(AutoConfigurationImportSelector.class)
</code></pre>
</li>
</ul>
</li>
</ul>
<h3 id="自动化配置">自动化配置</h3>
<ul>
<li><code>spring.factories</code>，这是自动配置的根源</li>
<li><code>WebMvcAutoConfiguration</code>自动配置类</li>
<li>所有SpringBoot的自动配置都在<code>springboot-autoconfigure</code>的包中</li>
</ul>
<pre><code class="language-java">/*
	SpringBoot的启动类		
*/
@SpringBootApplication
public class DemoApp {
    public static void main(String[] args) {
        SpringApplication.run(DemoApp.class);
    }
}

/*
	run方法的具体实现,就是新建了一个SpringApplication
*/
public static ConfigurableApplicationContext run(Class&lt;?&gt;[] primarySources,
                                                 String[] args) {
    return new SpringApplication(primarySources).run(args);
}

/*
	
*/
public SpringApplication(ResourceLoader resourceLoader, Class&lt;?&gt;... primarySources) {
    this.resourceLoader = resourceLoader;
    Assert.notNull(primarySources, &quot;PrimarySources must not be null&quot;);
    this.primarySources = new LinkedHashSet&lt;&gt;(Arrays.asList(primarySources));
    this.webApplicationType = WebApplicationType.deduceFromClasspath();
    setInitializers((Collection) getSpringFactoriesInstances(
        ApplicationContextInitializer.class));
    setListeners((Collection) getSpringFactoriesInstances(ApplicationListener.class));
    this.mainApplicationClass = deduceMainApplicationClass();
}
</code></pre>
<figure data-type="image" tabindex="5"><img src="https://gitee.com/a1021809072/mypic/raw/master/img/2020042709145967.png" alt="" loading="lazy"></figure>
<h3 id="配置文件">配置文件</h3>
<h4 id="基本依赖">基本依赖</h4>
<pre><code class="language-xml">&lt;!--这是父依赖--&gt;
&lt;parent&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;
    &lt;version&gt;2.4.2&lt;/version&gt;
    &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;
&lt;/parent&gt;


&lt;dependencies&gt;
    &lt;!--thymeleaf的启动器--&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;
    &lt;/dependency&gt;
    &lt;!--测试的启动器--&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;
        &lt;scope&gt;test&lt;/scope&gt;
    &lt;/dependency&gt;
    &lt;!--web的启动器--&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;
</code></pre>
<p>Thymeleaf的模板</p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;  xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Title&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;h3&gt;Hello world&lt;/h3&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p><a href="https://docs.spring.io/spring-boot/docs/2.1.6.RELEASE/reference/htmlsingle/#boot-features-external-config">官方外部配置文件说明参考文档</a></p>
<p>SpringBoot使用一个全局的配置文件，配置文件名称是固定的</p>
<p>**作用：**修改SpringBoot自动配置的默认值</p>
<ul>
<li>
<p>application.properties</p>
<ul>
<li>语法结构：key=value</li>
</ul>
</li>
<li>
<p>application.yml</p>
<ul>
<li>
<p>语法结构： key: 空格 value</p>
</li>
<li>
<p>YAML是一个可读性高、用来表达数据序列化的格式</p>
</li>
<li>
<p><strong>YAML可以直接给实体类赋值</strong></p>
<ul>
<li>需要一个注解(<code>@ConfigurationProperties(prefix=&quot;类名&quot;)</code>)</li>
</ul>
</li>
<li>
<p>application.yaml(<strong>基础语法</strong>)</p>
<ul>
<li>
<pre><code class="language-yaml"># 对空格的要求非常高
# 普通的key-value
name: springboot
# 对象
student:
	name: zhangsan
	age: 3
# 行内写法
student: {name:zhangsan,age:3}  # 以逗号分割

# 数组
pets:
 - cat
 - dog
# 另一种写法
pets: [cat,dog]
</code></pre>
</li>
</ul>
</li>
<li>
<p>application.properties</p>
<ul>
<li>
<pre><code class="language-properties"># 普通的key-value
name: springboot
#对象
student.name=zhangsan
student.age=3
</code></pre>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong><code>@PropertySource(value=&quot;classpath:xxx.properties&quot;)</code>用来加载指定springboot的配置文件</strong></p>
<h4 id="通过yaml进行赋值">通过YAML进行赋值</h4>
<p>1、Dog类</p>
<pre><code class="language-java">@Component  //将dog类交给spring管理
@ConfigurationProperties(prefix = &quot;dog&quot;)  //需要配置这个注解才能将值赋值给对象,前缀的值是需要赋值的对象名
public class Dog {
    private Integer id;
    private String name;
    private Integer age;
	//getter,setter,constructer,toString就当作写了..
}
</code></pre>
<p>2、application.yaml</p>
<pre><code class="language-yaml">dog:
  id: 1
  name: 旺财
  age: 3
</code></pre>
<p>3.测试</p>
<pre><code class="language-java">package com.m1sury;

import com.m1sury.pojo.Dog;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.context.properties.ConfigurationProperties;
import org.springframework.boot.test.context.SpringBootTest;

@SpringBootTest
class Springboot01DemoApplicationTests {
    @Autowired
    private Dog dog;
    @Test
    void contextLoads() {
        System.out.println(dog);
    }
}
</code></pre>
<figure data-type="image" tabindex="6"><img src="https://gitee.com/a1021809072/mypic/raw/master/img/image-20210131144038888.png" alt="image-20210131144038888" loading="lazy"></figure>
<h4 id="配置文件的优先级">配置文件的优先级</h4>
<figure data-type="image" tabindex="7"><img src="https://gitee.com/a1021809072/mypic/raw/master/img/image-20210615193614842.png" alt="image-20210615193614842" loading="lazy"></figure>
<p><strong>如果配置文件不想放在默认目录下，也可以放在其他位置，以上是springboot配置文件可存放的位置</strong></p>
<p>比如：</p>
<p>1、<code>project/config/application.properties</code>  项目下的config目录</p>
<p>2、<code>project/application.properties</code>  项目根目录下的<code>application.properties</code></p>
<p>3、<code>project/resources/config/application.properties</code>，项目classpath下的<code>config</code>目录下的<code>application.properties</code></p>
<p>4、<code>project/resources/application.properties</code> ，项目classpath根目录的<code>application.properties</code></p>
<p><strong>但是名字必须是<code>application</code>，格式可以是<code>properties</code>和<code>yaml</code></strong></p>
<p><strong>以上就是四个配置文件存放处的优先级，越往上，优先级越高</strong></p>
<p><strong>所以,默认配置的配置文件优先级是最低的，而且如果同一个目录下，有<code>application.yml</code>和<code>application.properties</code>，默认先读取<code>application.properties</code></strong></p>
<h4 id="springboot多环境下的配置文件">SpringBoot多环境下的配置文件</h4>
<h5 id="1-通过properties文件">1、通过properties文件</h5>
<pre><code class="language-shell"># 新建两个配置文件,一个是开发环境下的,一个是测试环境下的
application-dev.properties
application-test.properties
</code></pre>
<pre><code class="language-properties"># springboot的多环境配置: 可以选择激活哪一个配置文件
spring.profiles.active=dev  
#写成dev就激活开发的配置文件,test就激活测试的配置文件
</code></pre>
<h5 id="2-通过yaml文件">2、通过YAML文件</h5>
<p>yaml中通过<code>---</code>分割环境</p>
<pre><code class="language-yaml"># 这样就默认激活8081端口
server:
 port: 8081
# 也可以选择激活的端口
spring:
 profiles:
  active:dev  # 这样就会激活开发环境的端口
---
server:
 port: 8082
spring:
 profiles: dev
---
server:
 port: 8083
</code></pre>
<h4 id="数据库连接">数据库连接</h4>
<pre><code class="language-yaml">spring:
  datasource:
    username: root
    password: 123
    url: jdbc:mysql://localhost:3306/exe?useUnicode=true&amp;characterEncoding=utf-8
    driver-class-name: com.mysql.cj.jdbc.Driver
</code></pre>
<h3 id="springboot-2">SpringBoot</h3>
<h3 id="web开发">Web开发</h3>
<h4 id="静态资源">静态资源</h4>
<p>1、在springboot，可以使用以下方式处理静态资源</p>
<p>1.1、静态资源的存放目录</p>
<p><strong>静态资源映射的是<code>/**</code>,所以同名的静态资源和同名的请求,是先去找Controller能否处理,不能处理才去寻找静态资源处理器</strong></p>
<ul>
<li>
<p>webjars的根目录</p>
<ul>
<li>通过<code>localhost:8080/webjars</code>+文件名访问</li>
<li><mark>一般不用</mark></li>
</ul>
</li>
<li>
<p>resources目录下的<code>public</code>   ,<code>static</code>,   <code>/**</code>,  <code>resources</code>(resources目录下的resources)</p>
<p>通过 <code>localhost:8080/</code>+文件名即可访问</p>
</li>
<li>
<p><code>/META-INF/resources</code></p>
</li>
</ul>
<p>2、优先级：resources&gt;static(默认)&gt;public</p>
<p><strong>首页默认配置</strong></p>
<ul>
<li>静态资源路径下的<code>index.html</code></li>
<li>controller能处理<code>/index</code>的请求</li>
</ul>
<pre><code class="language-java">private Resource getWelcomePage() {
    //this.resourceProperties.getStaticLocations代表可以去找自定义的静态目录
    for (String location : this.resourceProperties.getStaticLocations()) {
        Resource indexHtml = getIndexHtml(location);
        if (indexHtml != null) {
            return indexHtml;
        }
    }
    ServletContext servletContext = getServletContext();
    if (servletContext != null) {
        return getIndexHtml(new ServletContextResource(servletContext, SERVLET_LOCATION));
    }
    return null;
}

//对于首页的定制,只需要在上方四个目录中一个创建index.html，localhost:8080就会映射到这个文件下
private Resource getIndexHtml(Resource location) {
    try {
        Resource resource = location.createRelative(&quot;index.html&quot;);
        if (resource.exists() &amp;&amp; (resource.getURL() != null)) {
            return resource;
        }
    }
    catch (Exception ex) {
    }
    return null;
}

</code></pre>
<h4 id="首页">首页</h4>
<h5 id="网页图标">网页图标</h5>
<p>1、网页的顶部图标可以在resources目录下创建一个<code>favicon.ico</code>文件作为网页的图标</p>
<p>2、通过创建文件后，还要在<code>application.properties</code>中配置</p>
<pre><code class="language-properties"># 关闭默认图标.才能使自定义的目标生效
spring.mvc.favicon.enabled=false
</code></pre>
<h5 id="首页的配置">首页的配置</h5>
<p>1、所有页面的静态资源都需要使用thymeleaf接管,<code>@{ }</code></p>
<p>2、页面国际化</p>
<p>2.1、在Resources目录下创建<code>i18n</code>文件夹</p>
<p>2.2、在<code>i18n</code>文件夹下创建<code>login_en_US.properties</code>或者<code>login_zh_CN.properties</code>文件</p>
<p>2.3、在Resource Bundle里面配置,或者在properties文件里写也可以</p>
<figure data-type="image" tabindex="8"><img src="https://gitee.com/a1021809072/mypic/raw/master/img/image-20210201134214305.png" alt="image-20210201134214305" loading="lazy"></figure>
<pre><code class="language-properties"># login_zh_CN.properties
login.password=密码
login.remember=记住我
login.tip=请登录
</code></pre>
<pre><code class="language-properties"># login_en_US.properties
login.password=password
login.remember=Remember me
login.tip=please sign in
</code></pre>
<pre><code class="language-properties"># 默认配置
login.password=密码
login.remember=记住我
login.tip=请登录
</code></pre>
<p>2.4、需要在application.properties文件中配置</p>
<pre><code class="language-properties"># 配置文件的真实位置
spring.messages.basename=i18n.login
</code></pre>
<h5 id="springmvc扩展">springmvc扩展</h5>
<p>springmvc的自动配置类在<code>webMvcAutoConfiguration</code></p>
<pre><code class="language-java">package com.m1sury.config;

import org.springframework.context.annotation.Configuration;
import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;
@Configuration
public class MyMvcConfig implements WebMvcConfigurer {
}
</code></pre>
<p><strong>消息转换(日期格式)</strong></p>
<pre><code class="language-java">/*
	日期格式:默认`dd/MM/yyyy`
*/
</code></pre>
<p>修改格式</p>
<pre><code class="language-properties"># 自定义的配置日期格式化
spring.mvc.date-formate=&quot;dd-MM-yyyy&quot;
</code></pre>
<h4 id="请求参数处理">请求参数处理</h4>
<p><strong>仅限于表单提交使用REST的时候</strong></p>
<p>Rest风格支持(使用HTTP请求方式动词来表示对资源的操作)</p>
<p>HiddenHttpMethodFilter.java</p>
<pre><code class="language-java">//通过POST的请求,并且在name=&quot;_method&quot;的input框中value的值就是真正需要的请求方式
@Override
	protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain)
			throws ServletException, IOException {

		HttpServletRequest requestToUse = request;

		if (&quot;POST&quot;.equals(request.getMethod()) &amp;&amp; request.getAttribute(WebUtils.ERROR_EXCEPTION_ATTRIBUTE) == null) {
			String paramValue = request.getParameter(this.methodParam);
			if (StringUtils.hasLength(paramValue)) {
				String method = paramValue.toUpperCase(Locale.ENGLISH);
				if (ALLOWED_METHODS.contains(method)) {
					requestToUse = new HttpMethodRequestWrapper(request, method);
				}
			}
		}

		filterChain.doFilter(requestToUse, response);
	}
</code></pre>
<ul>
<li>
<p>同一个请求</p>
</li>
<li>
<p>请求的方式不同,但是默认只能处理POST和GET的请求</p>
</li>
<li>
<p>核心: <code>HiddenHttpMethodFilter</code></p>
<ul>
<li>用法: 表单method=post,隐藏域 <code>_method=put</code></li>
<li>SpringBoot中手动开启</li>
</ul>
<pre><code class="language-java">	@Bean
	@ConditionalOnMissingBean(HiddenHttpMethodFilter.class)
	//如果不配置的话,默认是关闭的
	@ConditionalOnProperty(prefix = &quot;spring.mvc.hiddenmethod.filter&quot;, name = &quot;enabled&quot;, matchIfMissing = false)
	public OrderedHiddenHttpMethodFilter hiddenHttpMethodFilter() {
		return new OrderedHiddenHttpMethodFilter();
	}
</code></pre>
<pre><code class="language-yml"># 需要手动开启才可以支持REST风格的请求
spring.mvc.hiddenmethod.filter.enabled=true
</code></pre>
<pre><code class="language-html">&lt;form action=&quot;/user&quot; method=&quot;post&quot;&gt;
    &lt;input name=&quot;_method&quot; type=&quot;hidden&quot; value=&quot;PUT&quot;/&gt;
    &lt;input value=&quot;REST-PUT提交&quot; type=&quot;submit&quot;/&gt;
&lt;/form&gt;
&lt;form action=&quot;/user&quot; method=&quot;post&quot;&gt;
    &lt;input name=&quot;_method&quot; type=&quot;hidden&quot; value=&quot;DELETE&quot;/&gt;
    &lt;input value=&quot;REST-DELETE提交&quot; type=&quot;submit&quot;/&gt;
&lt;/form&gt;
</code></pre>
</li>
</ul>
<p>REST原理(表单提交要使用REST的时候)</p>
<ul>
<li>表单提交会带上<code>_method=PUT</code></li>
<li>请求过来会被<code>HiddenHttpMethodFilter</code>拦截
<ul>
<li>请求是否正常,并且是POST
<ul>
<li>获取到<code>_method</code>的值</li>
<li>大小写忽略</li>
<li>兼容以下请求: <strong>PUT,DELETE,PATCH</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="整合jsp">整合jsp</h3>
<h4 id="applicationyml">application.yml</h4>
<pre><code class="language-yaml"># 数据库端口
server:
  port: 8080
# Spring的数据源
spring:
  datasource:
    url: jdbc:mysql:///exe
    username: root
    password: 123
# MVC的视图解析器
  mvc:
    view:
      prefix: /WEB-INF/jsp/
      suffix: .jsp
      # 放行静态资源
    static-path-pattern: /static/**
# mybatis中mapper文件的路径
mybatis:
  mapper-locations: classpath:mapper/*.xml
# 类名的别名 填入实体类的包名
  type-aliases-package: com.m1sury.dto
</code></pre>
<h4 id="webapp文件夹的创建">webapp文件夹的创建</h4>
<p>webapp文件夹需要自己手动创建,包含WEB-INF文件夹也是</p>
<figure data-type="image" tabindex="9"><img src="https://gitee.com/a1021809072/mypic/raw/master/img/image-20210224205637015.png" alt="image-20210224205637015" loading="lazy"></figure>
<figure data-type="image" tabindex="10"><img src="https://gitee.com/a1021809072/mypic/raw/master/img/image-20210224205800917.png" alt="image-20210224205800917" loading="lazy"></figure>
<h3 id="springboot整合thymeleaf">SpringBoot整合Thymeleaf</h3>
<p><code>thymeleaf</code>的<code>pom.xml</code>依赖</p>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;org.thymeleaf&lt;/groupId&gt;
    &lt;artifactId&gt;thymeleaf-spring5&lt;/artifactId&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.thymeleaf.extras&lt;/groupId&gt;
    &lt;artifactId&gt;thymeleaf-extras-java8time&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
<p><strong>在templates目录下的所有页面,只能通过controller来跳转,功能类似于WEB-INF</strong></p>
<p>访问templates需要添加依赖</p>
<h5 id="模板引擎">模板引擎</h5>
<p><code>ThymeleafProperties.java</code></p>
<pre><code class="language-java">//默认编码
private static final Charset DEFAULT_ENCODING = StandardCharsets.UTF_8;
//默认前缀
public static final String DEFAULT_PREFIX = &quot;classpath:/templates/&quot;;
//默认后缀
public static final String DEFAULT_SUFFIX = &quot;.html&quot;;
</code></pre>
<p>只有需要使用thymeleaf,只需要导入对应依赖即可,将html放在templates目录下就可以了</p>
<p><code>application.yml</code></p>
<pre><code class="language-yml"># thymeleaf的配置
spring:
  thymeleaf:
    mode: HTML5
    encoding: utf-8
    cache: false
    # 放行静态资源
  static-path-pattern: /static/**
</code></pre>
<p>1、导入</p>
<p>Thymeleaf的约束<code>&lt;html xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;</code></p>
<pre><code class="language-html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; media=&quot;all&quot; th:href=&quot;@{/css/xx.css}&quot;&gt;
&lt;p th:text=&quot;#{home.welcome}&quot;&gt;Welcome to Thymeleaf&lt;/p&gt;
</code></pre>
<h5 id="简单的表达式">简单的表达式</h5>
<ul>
<li>变量：使用<code>${}</code></li>
</ul>
<pre><code class="language-html">&lt;!-- 假设msg是字符串,值为&lt;h3&gt;张三&lt;/h3&gt;--&gt;
&lt;h5 th:text=&quot;${msg}&quot;&gt;&lt;/h5&gt;&lt;!--这个msg会原样输出&lt;h3&gt;张三&lt;/h3&gt;--&gt;
&lt;h5 th:utext=&quot;${msg}&quot;&gt;&lt;/h5&gt;&lt;!--这msg会加粗加大--&gt;
</code></pre>
<ul>
<li>取链接的值使用<code>@{}</code></li>
<li>使用Thymeleaf遍历集合或数组</li>
</ul>
<pre><code class="language-html">&lt;!-- list里面装的 1,2,3--&gt;
&lt;table&gt;
    &lt;tr th:each=&quot;stu:${list}&quot; th:style=&quot;background-color:&quot;+&gt;&lt;/tr&gt;
    &lt;th&gt;
        &lt;!--user为遍历出来的每一个元素,list是需要遍历的集合,然后text取每一个元素的值--&gt;
    &lt;td th:each=&quot;user:${list}&quot; th:text=&quot;${user}&quot;&gt;&lt;/td&gt;
    &lt;!--两种都可以,效果都是一样的--&gt;
    &lt;td th:each=&quot;user:${list}&quot;&gt;[[${user}]]&lt;/td&gt;
    &lt;/th&gt;
&lt;/table&gt;
</code></pre>
<ul>
<li>条件判断：if/unless</li>
</ul>
<p>th:if 表示条件成立时显示内容,th:unless表示条件不成立时显示内容</p>
<ul>
<li>隔行变色</li>
</ul>
<pre><code class="language-java"> &lt;tr th:each=&quot;student,stat:${list}&quot; th:style=&quot;'background-color:'+@{${stat.odd}?'#F2F2'}&quot;&gt;
        &lt;td th:text=&quot;${stat.count}&quot;&gt;&lt;/td&gt;
        &lt;td th:text=&quot;${stat.index}&quot;&gt;&lt;/td&gt;
       &lt;td th:text=&quot;${student.id}&quot;&gt;&lt;/td&gt;
       &lt;td th:text=&quot;${student.sname}&quot;&gt;&lt;/td&gt;
       &lt;td th:text=&quot;${student.sage}&quot;&gt;&lt;/td&gt;
    &lt;/tr&gt;
</code></pre>
<h3 id="freemarkertodo">FreeMarker(TODO)</h3>
<p>FreeMarker是一款模板引擎,即一种基于模板和要改变的数据，并用来生成输出文本（HTML网页，电子邮件，配置文件，源代码等）的通用工具，是一个java类库</p>
<p>FreeMarker被设计用来生成Html Web页面，特别是基于MVC模式的应用程序</p>
<h3 id="springboot整合jsp">SpringBoot整合JSP</h3>
<pre><code class="language-xml">&lt;!-- 添加servlet依赖模块 --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;javax.servlet&lt;/groupId&gt;
    &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt;
    &lt;scope&gt;provided&lt;/scope&gt;
&lt;/dependency&gt;
&lt;!-- 添加jstl标签库依赖模块 关于c标签的一系列操作--&gt;
&lt;dependency&gt;
    &lt;groupId&gt;javax.servlet&lt;/groupId&gt;
    &lt;artifactId&gt;jstl&lt;/artifactId&gt;
&lt;/dependency&gt;
&lt;!--添加tomcat依赖模块.--&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt;
    &lt;scope&gt;provided&lt;/scope&gt;
&lt;/dependency&gt;
&lt;!-- 使用jsp引擎，springboot内置tomcat没有此依赖 --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.apache.tomcat.embed&lt;/groupId&gt;
    &lt;artifactId&gt;tomcat-embed-jasper&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
<p><code>application.yml</code></p>
<pre><code class="language-yml"># 配置数据源 使用默认的Hikari数据源
spring:
  datasource:
    url: jdbc:mysql:///exe
    username: root
    password: 123
    # 配置视图解析器
  mvc:
    view:
      prefix: classpath:/templates/
      suffix: .html
  # 配置mybatis的mapper路径以及类名别名
mybatis:
  mapper-locations: classpath:/mapper/*.xml
  type-aliases-package: com.m1sury.dto
</code></pre>
<h3 id="springboot整合mybatis">SpringBoot整合<a href="https://mybatis.org/mybatis-3/zh/index.html">Mybatis</a></h3>
<p>pom.xml(依赖)</p>
<pre><code class="language-xml">&lt;!--springboot的父依赖--&gt;
&lt;parent&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;
    &lt;version&gt;2.4.2&lt;/version&gt;
    &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;
&lt;/parent&gt;
&lt;properties&gt;
    &lt;java.version&gt;1.8&lt;/java.version&gt;
&lt;/properties&gt;
&lt;dependencies&gt;
    &lt;!--jdbc的启动器--&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt;
    &lt;/dependency&gt;
    &lt;!--web的启动器--&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
    &lt;/dependency&gt;
	&lt;!--mysql连接--&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;mysql&lt;/groupId&gt;
        &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
        &lt;scope&gt;runtime&lt;/scope&gt;
    &lt;/dependency&gt;
    &lt;!--测试的启动器--&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;
        &lt;scope&gt;test&lt;/scope&gt;
    &lt;/dependency&gt;
    &lt;!--mybatis整合springboot --&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;
        &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;
        &lt;version&gt;2.1.4&lt;/version&gt;
    &lt;/dependency&gt;

&lt;/dependencies&gt;

&lt;build&gt;
    &lt;plugins&gt;
        &lt;plugin&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;
        &lt;/plugin&gt;
    &lt;/plugins&gt;
&lt;/build&gt;
</code></pre>
<p>1、创建bean</p>
<p>2、创建Mapper</p>
<pre><code class="language-java">//这个注解表示了这是mybatis是mapper类
//第二种方式是在application类中加入@MapperScan(&quot;com.m1sury.mapper&quot;)
@Mapper
public interface UserMapper {
List&lt;User&gt; findAll();
    User findById(Integer id);
    int addUser(User user);
    int updateUser(User user);
    int delUser(int id);
}
</code></pre>
<p>3、mapper.xml</p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE mapper
        PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;
        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;
&lt;mapper namespace=&quot;com.m1sury.dao.UserMapper&quot;&gt;
    &lt;select resultType=&quot;com.m1sury.bean.User&quot; id=&quot;findAll&quot;&gt;
        select * from user
    &lt;/select&gt;
    &lt;select resultType=&quot;com.m1sury.bean.User&quot; id=&quot;findById&quot;&gt;
        select * from user where uid=#{uid}
    &lt;/select&gt;
    &lt;insert id=&quot;addUser&quot;&gt;
        insert into user values(#{uid},#{uname},#{upwd});
    &lt;/insert&gt;
    &lt;update id=&quot;updateUser&quot;&gt;
        update user set uname=#{uname},upwd=#{upwd} where uid=#{uid}
    &lt;/update&gt;
    &lt;delete id=&quot;delUser&quot;&gt;
        delete from user where uid=#{uid}
    &lt;/delete&gt;
&lt;/mapper&gt;
</code></pre>
<p><strong>4、application.properties配置文件中的关于mybatis的配置,classpath指的是resource目录</strong></p>
<pre><code class="language-properties"># 连接数据库
spring.datasource.username=root
spring.datasource.password=123
spring.datasource.url=jdbc:mysql://localhost:3306/exe
spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver

# 整合mybatis  
mybatis.type-aliases-package=com.m1sury.bean
# 表示resource目录下的mybatis目录下的mapper目录下的xml文件
mybatis.mapper-locations=classpath:mybatis/mapper/*.xml
</code></pre>
<p><strong><mark>需要将Dao接口交给Spring管理,这里说的是上面第二点的内容</mark></strong></p>
<pre><code class="language-java">package com.m1sury;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.boot.context.properties.ConfigurationProperties;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.PropertySource;

@SpringBootApplication
@MapperScan(&quot;com.m1sury.mapper&quot;)
public class DemoApplication {

    public static void main(String[] args) {
        SpringApplication.run(DemoApplication.class, args);
    }

}

</code></pre>
<hr>
<h3 id="springboot整合jpa">SpringBoot整合<a href="https://spring.io/projects/spring-data-jpa">JPA</a></h3>
<h4 id="常用注解">常用注解</h4>
<p>1、<code>@Entity+@Table</code> 标注在实体类上，表示是一个实体，并且如果表名和实体类名一样，可以省略table，否则加上<code>@Table(name=&quot;表名&quot;)</code></p>
<p>2、<code>@NoRepositoryBean</code> 标注在父类中repository，表示spring不会去实例化它。</p>
<p>3、<code>@Column</code>：标注在属性上，如果字段名与列名相同，则可以省略。</p>
<p>4、 <code>@Id</code>：标注在主键上，表示该属性为主键。一般还结合了@GeneratedValue()，主键的策略，默认是自增，等同于   @GeneratedValue(strategy= GenerationType.AUTO)</p>
<p>5、<code>@Transient</code>：表示该属性并非一个到数据库表的字段的映射,ORM框架将忽略该属性。如果一个属性并非数据库表的字段映射,就务必将其标示为@Transient,否则,ORM框架默认其注解为@Basic。@Basic(fetch=FetchType.LAZY)：标记可以指定实体属性的加载方式</p>
<p>6、<code>@JoinColumn（name=”role_id”）</code>:  标注在连接的属性上(一般多对1的1)，指定了本类用1的外键名叫什么。</p>
<p>​    <code>@JoinTable(name=&quot;996_permission_role&quot;)</code> ：标注在连接的属性上(一般多对多)，指定了多对多的中间表叫什么。</p>
<p>​    备注：Join的标注，和下面几个标注的mappedBy属性互斥！</p>
<p>7、<code>@ManyToMany</code>、<code>@OneToMany</code>、<code>@ManyToOne</code>：标注在连接的属性上，多对多，1对多，多对1</p>
<p>​    属性1： <code>mappedBy=&quot;permissions&quot;</code> 表示，当前类不维护状态，属性值其实是本类在被标注的链接属性上的链接属性，此案例的本类时Permission，连接属性是roles,连接属性的类的连接属性是permissions</p>
<p>​    属性2： <code>fetch = FetchType.LAZY</code> 表示是不是懒加载，默认是，可以设置成FetchType.EAGER</p>
<p>​    属性3：<code>cascade=CascadeType.ALL</code> 表示当前类操作时，被标注的连接属性如何级联，比如班级和学生是1对多关系，cascade标注在班级类中，那么执行班级的save操作的时候(班级.学生s.add(学生))，能级联保存学生,否则报错，需要先save学生，变成持久化对象，在班级.学生s.add(学生)</p>
<p>​    注意:只有<code>OneToOne</code>，<code>OneToMany</code>，<code>ManyToMany</code>上才有mappedBy属性，<code>ManyToOne</code>不存在该属性；</p>
<h4 id="基本流程">基本流程</h4>
<p>1、目录结构(webapp可有可无,整合thymeleaf可以删除webapp)</p>
<figure data-type="image" tabindex="11"><img src="https://gitee.com/a1021809072/mypic/raw/master/img/image-20210226102950597.png" alt="image-20210226102950597" loading="lazy"></figure>
<p>2、<code>pom.xml</code></p>
<pre><code class="language-xml">&lt;!--springData-jpa--&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt;
&lt;/dependency&gt;
&lt;!--Spring-web--&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
&lt;/dependency&gt;
&lt;!--热部署--&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;
    &lt;scope&gt;runtime&lt;/scope&gt;
    &lt;optional&gt;true&lt;/optional&gt;
&lt;/dependency&gt;
&lt;!--mysql数据库连接--&gt;
&lt;dependency&gt;
    &lt;groupId&gt;mysql&lt;/groupId&gt;
    &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
    &lt;scope&gt;runtime&lt;/scope&gt;
    &lt;version&gt;5.1.29&lt;/version&gt;
&lt;/dependency&gt;
&lt;!--druid数据源--&gt;
&lt;dependency&gt;
    &lt;groupId&gt;com.alibaba&lt;/groupId&gt;
    &lt;artifactId&gt;druid&lt;/artifactId&gt;
    &lt;version&gt;1.2.4&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<p>3、<code>application.properties</code>(只写了关于JPA的配置)</p>
<pre><code class="language-properties"># 应用名称
spring.application.name=demo
# 应用服务 WEB 访问端口
server.port=8080
# 数据库驱动：
spring.datasource.driver-class-name=com.mysql.jdbc.Driver
# 数据源名称
spring.datasource.name=defaultDataSource
# 数据库连接地址
spring.datasource.url=jdbc:mysql://localhost:3306/work01?serverTimezone=UTC
# 数据库用户名&amp;密码：
spring.datasource.username=root
spring.datasource.password=123
# 视图解析器
spring.mvc.view.prefix=/
spring.mvc.view.suffix=.jsp
# jpa相关
spring.jpa.database=mysql
spring.jpa.database-platform=mysql
spring.jpa.show-sql=true
# 数据库定义语言 create alter drop  DML:insert update delete  DQL:select
# DCL:grant  revoke    TCL:commit rollback
spring.jpa.hibernate.ddl-auto=update
# 方言   切换mysql的引擎为：InnoDB
spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.MySQL57Dialect
</code></pre>
<p>4、实体类<code>dto</code></p>
<p><strong><font color=red>多表连接的toString方法会引发<code>stackoverflow</code>栈溢出的异常</font></strong></p>
<pre><code class="language-java">@Entity //表明这是一个实体类
public class Student {
    @Id//标明该属性是主键
    //设置逐渐自增的策略
    @GeneratedValue(strategy = GenerationType.IDENTITY)//设置主键自增
    private Integer id;
    private String name;
    private String sex;
    private String birthday;
    private String hobby;
}
</code></pre>
<pre><code class="language-java">@Entity
public class Clazz {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Integer cid;
    private String cname;
    
    //以下是针对多表的操作
    @OneToMany(targetEntity = Student.class)//班级对应多个学生
    @JoinColumn(name = &quot;clazz_id&quot;)//student表外键与clazz对应
    @JsonIgnore//在json系列化时将java bean的一些属性忽略掉,序列化和反序列化都受影响
    private List&lt;Student&gt; list;

</code></pre>
<p>5、<code>dao</code>层,使用JPA，dao接口需要继承JPA默认的JPA仓库,就可以调用JPA自带的方法</p>
<pre><code class="language-java">//JPA仓库需要泛型的两个参数,使用的对象的类型,和主键的类型
public interface StuDao extends JpaRepository&lt;Student,Integer&gt; {
    //需要自带的方法可以自己手写方法
    //举个例子，以下的maxIdUser方法并不可行
    @Query(value = &quot;select * from t_user where id=(select max(id) from t_user)&quot;,nativeQuery = true)
    User maxIdUser();
}
</code></pre>
<blockquote>
<p>JPA自创方法的基本规范</p>
</blockquote>
<p>在Spring Data中，只要按照既定的规范命名方法，Spring Data Jpa就知道你想干嘛，这样就不用写SQL了,不过JPA写的语句是<strong>针对对象,而不是数据库的表</strong></p>
<p>默认使用的查询语言不是SQL，而是JPQL，这是一种数据库平台无关的面向对象的查询语言</p>
<blockquote>
<p>如果需要写SQL语句，可以使用注解**<code>@NativeQuery</code>**</p>
</blockquote>
<figure data-type="image" tabindex="12"><img src="https://gitee.com/a1021809072/mypic/raw/master/img/5-2.jpeg" alt="img" loading="lazy"></figure>
<p>6、service层 试验简单的demo</p>
<pre><code class="language-java">public interface StuService {
    //添加学生
    void addStu(Student stu);
    //删除学生
    void delStu(Integer id);
    //修改学生
    void updStu(Student stu);
    //查询学生
    List&lt;Student&gt; findStu();
    //添加班级
    void addCls(Clazz clazz);
}

</code></pre>
<p>7、Controller层</p>
<pre><code class="language-java">@Controller
public class PageController {
    @Autowired
    private StuService stuService;
    
    @RequestMapping(&quot;/list&quot;)
    public String list(Model model){
        List&lt;Student&gt; stu = stuService.findStu();
        model.addAttribute(&quot;list&quot;,stu);
        return &quot;list&quot;;
    }
}
</code></pre>
<p>8、页面<code>list.jsp</code></p>
<pre><code class="language-jsp">&lt;body&gt;
${list}
&lt;/body&gt;
</code></pre>
<p>9、测试运行,查看结果</p>
<figure data-type="image" tabindex="13"><img src="https://gitee.com/a1021809072/mypic/raw/master/img/image-20210226105431587.png" alt="image-20210226105431587" loading="lazy"></figure>
<hr>
<h3 id="springboot整合redis">SpringBoot整合<a href="https://redis.io/">Redis</a></h3>
<blockquote>
<p>Redis简介</p>
</blockquote>
<p>Redis是完全开源免费的一个高性能key-value内存数据库</p>
<p>这里只记录redis在项目中的使用</p>
<blockquote>
<p>业务： 将常用到的热点数据存入到redis中，减轻每次向数据库中查询的压力</p>
</blockquote>
<p>1、先尝试从redis中获取数据</p>
<p>2、判断获取到的数据是否为空，为空的话，则向数据库中查询。不为空的话，将查询到的数据返回给页面</p>
<p>3、如果为空的情况下，从数据库中查询到的数据应该存入redis中,这里使用到<code>ObjectMapper</code>转换,<code>ObjectMapper</code>和<code>TypeReference</code>都是<code>jackson</code>包中的</p>
<p>4、java中使用的redis操作对象是<code>RedisTemplate</code>,里面的泛型现阶段都使用String</p>
<p>类型，除了<code>RedisTemplate</code>可以使用,也可以使用<code>StringRedisTemplate</code>,就相当于<code>RedisTemplate&lt;String,String&gt;</code></p>
<pre><code class="language-java">@Autowired
    RedisTemplate&lt;String,String&gt; redisTemplate;
    @Override
    public List&lt;Faculty&gt; findFaculty() {
        String faculty = redisTemplate.boundValueOps(&quot;faculty&quot;).get();
        List&lt;Faculty&gt; list = null;
        ObjectMapper obj = new ObjectMapper();
        if(faculty!=null){// 说明里面是有值的
            try {
                 list= obj.readValue(faculty, new TypeReference&lt;List&lt;Faculty&gt;&gt;() {
                });
            } catch (JsonProcessingException e) {
                e.printStackTrace();
            }
        }else{
            //说明里面没有值,需要从数据库中查询
            list = stuDao.findFaculty();
            String s = null;
            try {
                s = obj.writeValueAsString(obj);
                //查询到并存入redis中
                redisTemplate.boundValueOps(s).set(&quot;faculty&quot;);
            } catch (JsonProcessingException e) {
                e.printStackTrace();
            }
        }
        return list;
    }
</code></pre>
<hr>
<h3 id="springboot中使用定时器">SpringBoot中使用定时器</h3>
<blockquote>
<p>1.添加pom.xml的依赖</p>
</blockquote>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
<blockquote>
<p>2.编写需要的组件并且交给Spring容器,并且需要编写定时的方法</p>
</blockquote>
<p><mark>编写定时方法的类一定要交给spring容器。否则不起作用</mark></p>
<blockquote>
<p>方法上添加<code>@Scheduled</code>注解</p>
</blockquote>
<blockquote>
<p>3.需要在注解内编写corn表达式，来表示需要多久执行一次任务</p>
</blockquote>
<pre><code class="language-java">@Component
public class ScheduledPrintNameService {
    @Scheduled(cron = &quot;0/5 * * * * *&quot;)
    public void printName(){
        System.out.println(&quot;1111&quot;+new Date());
    }
}
</code></pre>
<blockquote>
<p>4.在启动类中添加<code>@EnableScheduling</code>注解来启用定时器</p>
</blockquote>
<pre><code class="language-java">@SpringBootApplication
@EnableScheduling
public class DemoApplication {

    public static void main(String[] args) {
        SpringApplication.run(DemoApplication.class, args);
    }
}

</code></pre>
<blockquote>
<p>5.运行测试即可</p>
</blockquote>
<h3 id="springboot-邮件发送">SpringBoot 邮件发送</h3>
<blockquote>
<p>1.添加依赖</p>
</blockquote>
<pre><code class="language-xml">&lt;!--邮件发送--&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-mail&lt;/artifactId&gt;
&lt;/dependency&gt;
&lt;!--web依赖--&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
<blockquote>
<p>2.对于邮箱的配置文件</p>
</blockquote>
<pre><code class="language-properties"># 配置 SMTP 服务器地址
spring.mail.host=smtp.qq.com
# 服务器端口
spring.mail.port=587
# 配置邮箱用户名
spring.mail.username=qq邮箱
spring.mail.password=QQ邮箱的SMTP授权码,需要在QQ邮箱中设置
# 默认的邮件编码
spring.mail.defaultencoding=UTF8
# 配置SSL加密工厂
spring.mail.properties.mail.smtp.socketFactoryClass=javax.net.ssl.SSLSocketFactory
# 邮箱发送的日志会在控制台输出
spring.mail.properties.mail.debug=true
</code></pre>
<blockquote>
<p>3.编写代码</p>
</blockquote>
<pre><code class="language-java">@Controller
public class BookController {
    @Autowired
    private BookService bookService;
    @RequestMapping(&quot;list&quot;)
    public String list (Model model){
        List&lt;Book&gt; list = bookService.findAll();
        model.addAttribute(&quot;list&quot;, list);
        return &quot;list&quot;;
    }
    
    // 以下是主体代码
     @Autowired
    private JavaMailSender javaMailSender;
    @RequestMapping(&quot;message&quot;)
    public String message(){
        SimpleMailMessage simpleMailMessage = new SimpleMailMessage();
        //主题
        simpleMailMessage.setSubject(&quot;这是主题&quot;);
        //发送方
        simpleMailMessage.setFrom(&quot;1021809072@qq.com&quot;);
        //接收方
        simpleMailMessage.setTo(&quot;1021809072@qq.com&quot;);
        //发送的内容
        simpleMailMessage.setText(&quot;这是内容&quot;);
        javaMailSender.send(simpleMailMessage);
        return &quot;redirect:list&quot;;
    }
}

</code></pre>
<blockquote>
<p>4.查看结果</p>
</blockquote>
<figure data-type="image" tabindex="14"><img src="https://gitee.com/a1021809072/mypic/raw/master/img/image-20210304143437586.png" alt="image-20210304143437586" loading="lazy"></figure>
<hr>
<h3 id="springboot整合activemq">SpringBoot整合ActiveMQ</h3>
<h4 id="mq概述">MQ概述</h4>
<p>MQ(Message Queue)消息队列,是基础数据结构中“先进先出”的一种数据结构。一般用来解决<strong>应用解耦，异步消息，流量削峰</strong>等问题，实现高性能、高可用、可伸缩和最终一致性架构</p>
<h4 id="mq的缺点">MQ的缺点</h4>
<p>1、系统可用性降低。依赖服务也多，服务越容易挂掉。需要考虑MQ瘫痪的情况</p>
<p>2、系统复杂性提高。需要考虑消息丢失、消息重复消费、消息传递的顺序性</p>
<p>3、业务一致性。主业务和从属业务一致性的处理</p>
<h4 id="java操作activemq">Java操作activeMQ</h4>
<blockquote>
<p>1、pom.xml</p>
</blockquote>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-activemq&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
<blockquote>
<p>2、application.properties</p>
</blockquote>
<pre><code class="language-properties"># ActiveMQ相关
spring.activemq.user=admin
spring.activemq.password=admin
# 使用磁盘存储队列
spring.activemq.in-memory=false
# 设置通信端口
spring.activemq.broker-url=tcp://127.0.0.1:61616
spring.activemq.packages.trust-all=true
</code></pre>
<blockquote>
<p>3.启动类开启对消息队列的支持(<strong>2.2.2版本以后SpringBoot默认开启的</strong>)</p>
</blockquote>
<pre><code class="language-java">@SpringBootApplication
@EnableJms
public class DemoApplication {
    public static void main(String[] args) {
        SpringApplication.run(DemoApplication.class, args);
    }
}
</code></pre>
<blockquote>
<p>4.配置消息队列</p>
</blockquote>
<pre><code class="language-java">import org.apache.activemq.command.ActiveMQQueue;
import org.springframework.context.annotation.Bean;
import org.springframework.stereotype.Component;

import javax.jms.Queue;

@Component
public class QueueInit {
    //是jms包中的Queue
    @Bean //将队列装入IOC容器中
    Queue queue(){
        return new ActiveMQQueue(&quot;队列名&quot;);
    }
}
</code></pre>
<blockquote>
<p>5.生产者</p>
</blockquote>
<pre><code class="language-java">import com.bwie.dto.Student;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.jms.core.JmsMessagingTemplate;
import org.springframework.stereotype.Component;

import javax.jms.Queue;

@Component  //生产者
public class Producer {

    @Autowired
    private Queue queue;//盛放消息的容器

    @Autowired
    private JmsMessagingTemplate jmsMessagingTemplate;//赋予生产者生产消息的能力


    public void prod(Student student){

        jmsMessagingTemplate.convertAndSend(this.queue,student);
    }

}
</code></pre>
<blockquote>
<p>6.消费者</p>
</blockquote>
<pre><code class="language-java">import com.bwie.dto.Student;
import org.springframework.jms.annotation.JmsListener;
import org.springframework.stereotype.Component;

@Component
public class Customer {


    @JmsListener(destination = &quot;与上面的队列名对应&quot; )
    public void recive(Student student){

        System.out.println(&quot;消费者接受到的消息为：&quot;+student);
    }
}
</code></pre>
<pre><code class="language-java">package com.m1sury;

import com.m1sury.domain.Producer;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.ApplicationArguments;
import org.springframework.boot.ApplicationRunner;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.jms.annotation.EnableJms;

@SpringBootApplication
@EnableJms
public class DemoApplication implements ApplicationRunner {

    public static void main(String[] args) {
        SpringApplication.run(DemoApplication.class, args);
    }
    @Autowired
    private Producer producer;
    @Override
    public void run(ApplicationArguments args) throws Exception {
        producer.prod();
    }
}

</code></pre>
<blockquote>
<p>效果</p>
</blockquote>
<figure data-type="image" tabindex="15"><img src="C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210308160755090.png" alt="image-20210308160755090" loading="lazy"></figure>
<h3 id="springboot整合rabbitmq">SpringBoot整合RabbitMQ</h3>
<p>前提：需要先安装<code>Erlang</code>语言环境和RabbitMQ</p>
<p>下载erlang语言,[Erlang语言下载页面](<a href="https://www.erlang.org/downloads">Erlang Programming Language</a>),<a href="https://www.rabbitmq.com/download.html">RabbitMQ下载页面</a>),具体的安装方法略过</p>
<blockquote>
<p>1、<code>pom.xml</code></p>
</blockquote>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
<blockquote>
<p>2、<code>application.yml</code></p>
</blockquote>
<pre><code class="language-yaml">spring:
  rabbitmq:
    host: localhost
</code></pre>
<blockquote>
<p>3.服务提供者</p>
</blockquote>
<pre><code class="language-java">@RestController
public class ProviderController {
    @Autowired
    private RabbitTemplate rabbitTemplate;
    //直接模式
    @RequestMapping(&quot;/test&quot;)
    public String test(String msg){
        //第一个参数是队列名
        //第二个参数是具体发送的内容
        rabbitTemplate.convertAndSend(&quot;test&quot;,msg);
        return msg;
    }

    @GetMapping(&quot;/fen&quot;)
    public String fen(String msg){
        rabbitTemplate.convertAndSend(&quot;test&quot;,msg);
        return msg;
    }

    @GetMapping(&quot;/zhu&quot;)
    public String zhu(String msg){
        rabbitTemplate.convertAndSend(&quot;test&quot;,msg);
        return msg;
    }
}
</code></pre>
<blockquote>
<p>3.消费者&gt;监听</p>
</blockquote>
<pre><code class="language-java">@RabbitListener(queues = &quot;test&quot;) //queues是队列名
@Component //需要将监听的类装载入IOC容器
public class Listener {
    
    @RabbitHandler
    public void getMsg(String msg){
        System.out.println(msg);
    }
}
</code></pre>
<h3 id="springboot发送短信">SpringBoot发送短信</h3>
<p><a href="https://market.aliyun.com/products/56928004/cmapi023305.html?spm=5176.11065268.1996646101.searchclickresult.73797bcakSXVaf#sku=yuncode1730500007">阿里云的具体产品</a></p>
<p>请求参数：</p>
<ol>
<li>mobile 手机号</li>
<li>param  可选项，指的是验证码</li>
<li>tpi_id 必选，这里是模板id</li>
</ol>
<h4 id="基本的流程">基本的流程</h4>
<blockquote>
<p>1.将示例代码粘贴,需要添加验证码下面代码有</p>
</blockquote>
<pre><code class="language-java">public static void main(String[] args) {
	    String host = &quot;http://dingxin.market.alicloudapi.com&quot;;
	    String path = &quot;/dx/sendSms&quot;;
	    String method = &quot;POST&quot;;
	    String appcode = &quot;你自己的AppCode&quot;;
	    Map&lt;String, String&gt; headers = new HashMap&lt;String, String&gt;();
	    //最后在header中的格式(中间是英文空格)为Authorization:APPCODE 83359fd73fe94948385f570e3c139105
	    headers.put(&quot;Authorization&quot;, &quot;APPCODE &quot; + appcode);
	    Map&lt;String, String&gt; querys = new HashMap&lt;String, String&gt;();
	    querys.put(&quot;mobile&quot;, &quot;159xxxx9999&quot;);
	    querys.put(&quot;param&quot;, &quot;code:1234&quot;);
	    querys.put(&quot;tpl_id&quot;, &quot;TP1711063&quot;);
	    Map&lt;String, String&gt; bodys = new HashMap&lt;String, String&gt;();


	    try {
	    	/**
	    	* 重要提示如下:
	    	* HttpUtils请从
	    	* https://github.com/aliyun/api-gateway-demo-sign-java/blob/master/src/main/java/com/aliyun/api/gateway/demo/util/HttpUtils.java
	    	* 下载
	    	*
	    	* 相应的依赖请参照
	    	* https://github.com/aliyun/api-gateway-demo-sign-java/blob/master/pom.xml
	    	*/
	    	HttpResponse response = HttpUtils.doPost(host, path, method, headers, querys, bodys);
	    	System.out.println(response.toString());
	    	//获取response的body
	    	//System.out.println(EntityUtils.toString(response.getEntity()));
	    } catch (Exception e) {
	    	e.printStackTrace();
	    }
	}
</code></pre>
<blockquote>
<p>2.重要提示：HttpUtils和pom依赖</p>
</blockquote>
<p><code>PageUtils.java</code></p>
<pre><code class="language-java">package com.m1sury.demotest;

import java.io.UnsupportedEncodingException;
import java.net.URLEncoder;
import java.security.KeyManagementException;
import java.security.NoSuchAlgorithmException;
import java.security.cert.X509Certificate;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;

import javax.net.ssl.SSLContext;
import javax.net.ssl.TrustManager;
import javax.net.ssl.X509TrustManager;

import org.apache.commons.lang.StringUtils;
import org.apache.http.HttpResponse;
import org.apache.http.NameValuePair;
import org.apache.http.client.HttpClient;
import org.apache.http.client.entity.UrlEncodedFormEntity;
import org.apache.http.client.methods.HttpDelete;
import org.apache.http.client.methods.HttpGet;
import org.apache.http.client.methods.HttpPost;
import org.apache.http.client.methods.HttpPut;
import org.apache.http.conn.ClientConnectionManager;
import org.apache.http.conn.scheme.Scheme;
import org.apache.http.conn.scheme.SchemeRegistry;
import org.apache.http.conn.ssl.SSLSocketFactory;
import org.apache.http.entity.ByteArrayEntity;
import org.apache.http.entity.StringEntity;
import org.apache.http.impl.client.DefaultHttpClient;
import org.apache.http.message.BasicNameValuePair;

public class HttpUtils {
	
	/**
	 * get
	 * 
	 * @param host
	 * @param path
	 * @param method
	 * @param headers
	 * @param querys
	 * @return
	 * @throws Exception
	 */
	public static HttpResponse doGet(String host, String path, String method, 
			Map&lt;String, String&gt; headers, 
			Map&lt;String, String&gt; querys)
            throws Exception {    	
    	HttpClient httpClient = wrapClient(host);

    	HttpGet request = new HttpGet(buildUrl(host, path, querys));
        for (Map.Entry&lt;String, String&gt; e : headers.entrySet()) {
        	request.addHeader(e.getKey(), e.getValue());
        }
        
        return httpClient.execute(request);
    }
	
	/**
	 * post form
	 * 
	 * @param host
	 * @param path
	 * @param method
	 * @param headers
	 * @param querys
	 * @param bodys
	 * @return
	 * @throws Exception
	 */
	public static HttpResponse doPost(String host, String path, String method, 
			Map&lt;String, String&gt; headers, 
			Map&lt;String, String&gt; querys, 
			Map&lt;String, String&gt; bodys)
            throws Exception {    	
    	HttpClient httpClient = wrapClient(host);

    	HttpPost request = new HttpPost(buildUrl(host, path, querys));
        for (Map.Entry&lt;String, String&gt; e : headers.entrySet()) {
        	request.addHeader(e.getKey(), e.getValue());
        }

        if (bodys != null) {
            List&lt;NameValuePair&gt; nameValuePairList = new ArrayList&lt;NameValuePair&gt;();

            for (String key : bodys.keySet()) {
                nameValuePairList.add(new BasicNameValuePair(key, bodys.get(key)));
            }
            UrlEncodedFormEntity formEntity = new UrlEncodedFormEntity(nameValuePairList, &quot;utf-8&quot;);
            formEntity.setContentType(&quot;application/x-www-form-urlencoded; charset=UTF-8&quot;);
            request.setEntity(formEntity);
        }

        return httpClient.execute(request);
    }	
	
	/**
	 * Post String
	 * 
	 * @param host
	 * @param path
	 * @param method
	 * @param headers
	 * @param querys
	 * @param body
	 * @return
	 * @throws Exception
	 */
	public static HttpResponse doPost(String host, String path, String method, 
			Map&lt;String, String&gt; headers, 
			Map&lt;String, String&gt; querys, 
			String body)
            throws Exception {    	
    	HttpClient httpClient = wrapClient(host);

    	HttpPost request = new HttpPost(buildUrl(host, path, querys));
        for (Map.Entry&lt;String, String&gt; e : headers.entrySet()) {
        	request.addHeader(e.getKey(), e.getValue());
        }

        if (StringUtils.isNotBlank(body)) {
        	request.setEntity(new StringEntity(body, &quot;utf-8&quot;));
        }

        return httpClient.execute(request);
    }
	
	/**
	 * Post stream
	 * 
	 * @param host
	 * @param path
	 * @param method
	 * @param headers
	 * @param querys
	 * @param body
	 * @return
	 * @throws Exception
	 */
	public static HttpResponse doPost(String host, String path, String method, 
			Map&lt;String, String&gt; headers, 
			Map&lt;String, String&gt; querys, 
			byte[] body)
            throws Exception {    	
    	HttpClient httpClient = wrapClient(host);

    	HttpPost request = new HttpPost(buildUrl(host, path, querys));
        for (Map.Entry&lt;String, String&gt; e : headers.entrySet()) {
        	request.addHeader(e.getKey(), e.getValue());
        }

        if (body != null) {
        	request.setEntity(new ByteArrayEntity(body));
        }

        return httpClient.execute(request);
    }
	
	/**
	 * Put String
	 * @param host
	 * @param path
	 * @param method
	 * @param headers
	 * @param querys
	 * @param body
	 * @return
	 * @throws Exception
	 */
	public static HttpResponse doPut(String host, String path, String method, 
			Map&lt;String, String&gt; headers, 
			Map&lt;String, String&gt; querys, 
			String body)
            throws Exception {    	
    	HttpClient httpClient = wrapClient(host);

    	HttpPut request = new HttpPut(buildUrl(host, path, querys));
        for (Map.Entry&lt;String, String&gt; e : headers.entrySet()) {
        	request.addHeader(e.getKey(), e.getValue());
        }

        if (StringUtils.isNotBlank(body)) {
        	request.setEntity(new StringEntity(body, &quot;utf-8&quot;));
        }

        return httpClient.execute(request);
    }
	
	/**
	 * Put stream
	 * @param host
	 * @param path
	 * @param method
	 * @param headers
	 * @param querys
	 * @param body
	 * @return
	 * @throws Exception
	 */
	public static HttpResponse doPut(String host, String path, String method, 
			Map&lt;String, String&gt; headers, 
			Map&lt;String, String&gt; querys, 
			byte[] body)
            throws Exception {    	
    	HttpClient httpClient = wrapClient(host);

    	HttpPut request = new HttpPut(buildUrl(host, path, querys));
        for (Map.Entry&lt;String, String&gt; e : headers.entrySet()) {
        	request.addHeader(e.getKey(), e.getValue());
        }

        if (body != null) {
        	request.setEntity(new ByteArrayEntity(body));
        }

        return httpClient.execute(request);
    }
	
	/**
	 * Delete
	 *  
	 * @param host
	 * @param path
	 * @param method
	 * @param headers
	 * @param querys
	 * @return
	 * @throws Exception
	 */
	public static HttpResponse doDelete(String host, String path, String method, 
			Map&lt;String, String&gt; headers, 
			Map&lt;String, String&gt; querys)
            throws Exception {    	
    	HttpClient httpClient = wrapClient(host);

    	HttpDelete request = new HttpDelete(buildUrl(host, path, querys));
        for (Map.Entry&lt;String, String&gt; e : headers.entrySet()) {
        	request.addHeader(e.getKey(), e.getValue());
        }
        
        return httpClient.execute(request);
    }
	
	private static String buildUrl(String host, String path, Map&lt;String, String&gt; querys) throws UnsupportedEncodingException {
    	StringBuilder sbUrl = new StringBuilder();
    	sbUrl.append(host);
    	if (!StringUtils.isBlank(path)) {
    		sbUrl.append(path);
        }
    	if (null != querys) {
    		StringBuilder sbQuery = new StringBuilder();
        	for (Map.Entry&lt;String, String&gt; query : querys.entrySet()) {
        		if (0 &lt; sbQuery.length()) {
        			sbQuery.append(&quot;&amp;&quot;);
        		}
        		if (StringUtils.isBlank(query.getKey()) &amp;&amp; !StringUtils.isBlank(query.getValue())) {
        			sbQuery.append(query.getValue());
                }
        		if (!StringUtils.isBlank(query.getKey())) {
        			sbQuery.append(query.getKey());
        			if (!StringUtils.isBlank(query.getValue())) {
        				sbQuery.append(&quot;=&quot;);
        				sbQuery.append(URLEncoder.encode(query.getValue(), &quot;utf-8&quot;));
        			}        			
                }
        	}
        	if (0 &lt; sbQuery.length()) {
        		sbUrl.append(&quot;?&quot;).append(sbQuery);
        	}
        }
    	
    	return sbUrl.toString();
    }
	
	private static HttpClient wrapClient(String host) {
		HttpClient httpClient = new DefaultHttpClient();
		if (host.startsWith(&quot;https://&quot;)) {
			sslClient(httpClient);
		}
		
		return httpClient;
	}
	
	private static void sslClient(HttpClient httpClient) {
        try {
            SSLContext ctx = SSLContext.getInstance(&quot;TLS&quot;);
            X509TrustManager tm = new X509TrustManager() {
                public X509Certificate[] getAcceptedIssuers() {
                    return null;
                }
                public void checkClientTrusted(X509Certificate[] xcs, String str) {
                	
                }
                public void checkServerTrusted(X509Certificate[] xcs, String str) {
                	
                }
            };
            ctx.init(null, new TrustManager[] { tm }, null);
            SSLSocketFactory ssf = new SSLSocketFactory(ctx);
            ssf.setHostnameVerifier(SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);
            ClientConnectionManager ccm = httpClient.getConnectionManager();
            SchemeRegistry registry = ccm.getSchemeRegistry();
            registry.register(new Scheme(&quot;https&quot;, 443, ssf));
        } catch (KeyManagementException ex) {
            throw new RuntimeException(ex);
        } catch (NoSuchAlgorithmException ex) {
        	throw new RuntimeException(ex);
        }
    }
}
</code></pre>
<p><code>pom.xml</code></p>
<pre><code class="language-xml">&lt;dependency&gt;
            &lt;groupId&gt;com.alibaba&lt;/groupId&gt;
            &lt;artifactId&gt;fastjson&lt;/artifactId&gt;
            &lt;version&gt;1.2.15&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.apache.httpcomponents&lt;/groupId&gt;
            &lt;artifactId&gt;httpclient&lt;/artifactId&gt;
            &lt;version&gt;4.2.1&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.apache.httpcomponents&lt;/groupId&gt;
            &lt;artifactId&gt;httpcore&lt;/artifactId&gt;
            &lt;version&gt;4.2.1&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;commons-lang&lt;/groupId&gt;
            &lt;artifactId&gt;commons-lang&lt;/artifactId&gt;
            &lt;version&gt;2.6&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.eclipse.jetty&lt;/groupId&gt;
            &lt;artifactId&gt;jetty-util&lt;/artifactId&gt;
            &lt;version&gt;9.3.7.v20160115&lt;/version&gt;
        &lt;/dependency&gt;
</code></pre>
<h3 id="查询ip地址js实现">查询IP地址(JS实现)</h3>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;&lt;/head&gt;
&lt;body&gt;
    &lt;!--主要是下面这句--&gt;
&lt;script src=&quot;http://pv.sohu.com/cityjson&quot;&gt;&lt;/script&gt;
&lt;script&gt;
    &lt;!--以及这句--&gt;
document.write(returnCitySN['cip'] +&quot; &quot;+ returnCitySN['cname'])
&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h3 id="springboot页面集成ckeditor4">SpringBoot页面集成<a href="https://ckeditor.com/ckeditor-4/">CKeditor4</a></h3>
<p>下面代码只剩下主体部分</p>
<pre><code class="language-html">&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;
&lt;head&gt;
    &lt;script type=&quot;text/javascript&quot; src=&quot;../static/js/jquery-1.8.2.min.js&quot;&gt;&lt;/script&gt;
    &lt;script src=&quot;../static/ckeditor_4.15.1_full_easyimage/ckeditor/ckeditor.js&quot;&gt;&lt;/script&gt;
&lt;/head&gt;
    
&lt;body&gt;
    &lt;form&gt;
        &lt;textarea name=&quot;test&quot; id=&quot;editor1&quot;&gt;

        &lt;/textarea&gt;
    &lt;/form&gt;
&lt;/body&gt;
    &lt;script&gt;
        CKEDITOR.replace('editor1');
    &lt;/script&gt;
&lt;/html&gt;
</code></pre>
<h3 id="springboot整合fastdfs">SpringBoot整合<a href="https://baike.baidu.com/item/fastdfs/5609710">FastDFS</a></h3>
<blockquote>
<p>FastDFS的搭建 <a href="https://developer.aliyun.com/article/766350">FastDFS安装手册-阿里云开发者社区 (aliyun.com)</a></p>
</blockquote>
<p><code>pom.xml</code></p>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;com.github.tobato&lt;/groupId&gt;
    &lt;artifactId&gt;fastdfs-client&lt;/artifactId&gt;
    &lt;version&gt;1.26.2&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<p><code>application.yml</code></p>
<pre><code class="language-yaml">fdfs:
  tracker-list:
    - 192.168.25.133:22122 #存储服务器的ip及端口
  web-server-url: http://192.168.25.133/
  so-timeout: 1500
  connect-timeout: 500
  thumbImage:
    height: 150
    width: 150
</code></pre>
<p><code>FdfsConfigguration.java</code></p>
<pre><code class="language-java">package com.m1sury.config;

import com.github.tobato.fastdfs.FdfsClientConfig;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.EnableMBeanExport;
import org.springframework.context.annotation.Import;
import org.springframework.jmx.support.RegistrationPolicy;
 
/**
 * 
 */
@Configuration
@Import(FdfsClientConfig.class) // 导入FastDFS-Client组件
@EnableMBeanExport(registration = RegistrationPolicy.IGNORE_EXISTING) // 解决jmx重复注册bean的问题
public class FdfsConfiguration {
}
</code></pre>
<p><code>Controller</code></p>
<pre><code class="language-java">@RestController
public class UserController {
    @Autowired
    private FastFileStorageClient storageClient;
    
     @RequestMapping(&quot;/upload&quot;)
    public String upload(MultipartFile file){
        String fullPath=null;
        try {
            StorePath png = storageClient.uploadFile(file.getInputStream(), file.getSize(), &quot;png&quot;, null);
            fullPath = &quot;http://192.168.25.133/&quot;+png.getFullPath();
        } catch (IOException e) {
            e.printStackTrace();
        }
        System.out.println(fullPath);
        return fullPath;
    }
}
</code></pre>
<p><code>前端部分</code></p>
<pre><code class="language-html">&lt;!--基于AngularJS前端--&gt;
&lt;html&gt;
    &lt;head&gt;
        &lt;script src=&quot;js/angular.min.js&quot;&gt;&lt;/script&gt;
        &lt;script&gt;
        	var app=angular.module('pinyougou',[]);
            app.controller('a', function ($scope, $http) {
                $scope.upload=function () {
                    //js原生语法获取logo的文件域
                var file= document.getElementById(&quot;logo&quot;).files;
                //使用formdata传输图片
                var formdata = new FormData();
                formdata.append(&quot;file&quot;,file[0]);
                $http({
                    method:&quot;POST&quot;,
                    url:&quot;/upload&quot;,
                    data:formdata,
                    //Content-Type设置为undefined,浏览器会自动设置为multipart/form-data
                    headers:{&quot;Content-Type&quot;:undefined},
                    //通过设置 transformRequest: angular.identity ，anjularjs transformRequest function 将序列化我们的formdata object.
                    transformRequest:angular.identity
                })
            }
            }
        &lt;/script&gt;
    &lt;/head&gt;
    &lt;body ng-app=&quot;pinyougou&quot;  ng-controller=&quot;a&quot;&gt;
       头像:&lt;input type=&quot;file&quot; id=&quot;logo&quot; ng-change=&quot;upload()&quot; ng-model=&quot;entity.logo&quot;&gt;&lt;br&gt; 
    &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h3 id="springboot整合elasticsearchtodo">SpringBoot整合ElasticSearch(TODO)</h3>
<p><code>pom.xml</code></p>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-data-elasticsearch&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
<h3 id="springboot整合dubbotodo">SpringBoot整合Dubbo(TODO)</h3>
<blockquote>
<p>首先，需要将Zookeeper作为注册中心</p>
<p>下载地址:https://zookeeper.apache.org/</p>
</blockquote>
<p><code>parent-pom.xml</code></p>
<pre><code class="language-xml">&lt;properties&gt;
        &lt;junit.version&gt;4.12&lt;/junit.version&gt;
        &lt;dubbo-spring-boot.version&gt;2.7.11&lt;/dubbo-spring-boot.version&gt;
        &lt;spring-boot-dependencies.version&gt;2.1.4.RELEASE&lt;/spring-boot-dependencies.version&gt;
        &lt;mybatis-plus-boot.version&gt;3.2.0&lt;/mybatis-plus-boot.version&gt;
        &lt;pagehelper.version&gt;4.0.0&lt;/pagehelper.version&gt;
        &lt;pagehelper-spring-boot.version&gt;1.2.10&lt;/pagehelper-spring-boot.version&gt;
        &lt;dubbo.version&gt;2.8.4&lt;/dubbo.version&gt;
        &lt;mysql.version&gt;5.1.47&lt;/mysql.version&gt;
        &lt;druid.version&gt;1.0.29&lt;/druid.version&gt;
    &lt;/properties&gt;

    &lt;dependencyManagement&gt;
        &lt;dependencies&gt;
            &lt;!-- https://mvnrepository.com/artifact/org.apache.dubbo/dubbo-spring-boot-starter --&gt;
            &lt;dependency&gt;
                &lt;groupId&gt;org.apache.dubbo&lt;/groupId&gt;
                &lt;artifactId&gt;dubbo-spring-boot-starter&lt;/artifactId&gt;
                &lt;version&gt;${dubbo-spring-boot.version}&lt;/version&gt;
            &lt;/dependency&gt;
            &lt;!--SpringBoot--&gt;
            &lt;dependency&gt;
                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
                &lt;artifactId&gt;spring-boot-dependencies&lt;/artifactId&gt;
                &lt;version&gt;${spring-boot-dependencies.version}&lt;/version&gt;
                &lt;type&gt;pom&lt;/type&gt;
                &lt;scope&gt;import&lt;/scope&gt;
            &lt;/dependency&gt;
            &lt;!--mybatisPlus依赖启动器--&gt;
            &lt;dependency&gt;
                &lt;groupId&gt;com.baomidou&lt;/groupId&gt;
                &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt;
                &lt;version&gt;${mybatis-plus-boot.version}&lt;/version&gt;
            &lt;/dependency&gt;
            &lt;!--mysql依赖--&gt;
            &lt;dependency&gt;
                &lt;groupId&gt;mysql&lt;/groupId&gt;
                &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
                &lt;version&gt;${mysql.version}&lt;/version&gt;
                &lt;scope&gt;runtime&lt;/scope&gt;
            &lt;/dependency&gt;
            &lt;!--   阿里 Mysql连接池'德鲁伊'依赖    --&gt;
            &lt;dependency&gt;
                &lt;groupId&gt;com.alibaba&lt;/groupId&gt;
                &lt;artifactId&gt;druid&lt;/artifactId&gt;
                &lt;version&gt;${druid.version}&lt;/version&gt;
            &lt;/dependency&gt;
            &lt;dependency&gt;
                &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt;
                &lt;artifactId&gt;pagehelper-spring-boot-starter&lt;/artifactId&gt;
                &lt;version&gt;${pagehelper-spring-boot.version}&lt;/version&gt;
                &lt;exclusions&gt;
                    &lt;exclusion&gt;
                        &lt;groupId&gt;org.mybatis&lt;/groupId&gt;
                        &lt;artifactId&gt;mybatis&lt;/artifactId&gt;
                    &lt;/exclusion&gt;
                    &lt;exclusion&gt;
                        &lt;groupId&gt;org.mybatis&lt;/groupId&gt;
                        &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt;
                    &lt;/exclusion&gt;
                &lt;/exclusions&gt;
            &lt;/dependency&gt;
            &lt;dependency&gt;
                &lt;groupId&gt;com.alibaba&lt;/groupId&gt;
                &lt;artifactId&gt;fastjson&lt;/artifactId&gt;
                &lt;version&gt;1.2.47&lt;/version&gt;
            &lt;/dependency&gt;
        &lt;/dependencies&gt;
    &lt;/dependencyManagement&gt;
</code></pre>
<h4 id="实体类可以忽略">实体类(可以忽略)</h4>
<p><code>pom.xml</code></p>
<pre><code class="language-xml">&lt;!--lombok依赖(可以忽略)--&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;
    &lt;artifactId&gt;lombok&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
<h4 id="数据访问层dao">数据访问层(DAO)</h4>
<p><code>pom.xml</code></p>
<pre><code class="language-xml">&lt;!--此处省略实体类的依赖--&gt;

&lt;dependency&gt;
    &lt;groupId&gt;mysql&lt;/groupId&gt;
    &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;com.baomidou&lt;/groupId&gt;
    &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
<p><code>appliaction.yml</code></p>
<pre><code class="language-yaml">mybatis-plus:
  # 日志输出
  configuration:
    log-impl: org.apache.ibatis.logging.log4j2.Log4j2Impl
    # 开启驼峰命名
    map-underscore-to-camel-case: true
  # mapper文件的地址
  mapper-locations: classpath*:mapper/*.xml
  # 指定mybatis的实体目录
  type-aliases-package: com.m1sury.entity
</code></pre>
<h4 id="service实现层service接口继承实体类依赖即可">Service实现层,Service接口继承实体类依赖即可</h4>
<p><code>pom.xml</code></p>
<pre><code class="language-xml">&lt;!--实现类层继承接口层依赖--&gt;

&lt;dependency&gt;
    &lt;groupId&gt;org.apache.dubbo&lt;/groupId&gt;
    &lt;artifactId&gt;dubbo-spring-boot-starter&lt;/artifactId&gt;
&lt;/dependency&gt;
&lt;!-- https://mvnrepository.com/artifact/org.apache.curator/curator-framework --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.apache.curator&lt;/groupId&gt;
    &lt;artifactId&gt;curator-framework&lt;/artifactId&gt;
    &lt;version&gt;2.12.0&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt;
    &lt;artifactId&gt;pagehelper&lt;/artifactId&gt;
    &lt;version&gt;5.0.1&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<p><code>application.yml</code></p>
<pre><code class="language-yaml"># 应用服务 WEB 访问端口
server:
  port: 9001

###################################
# Spring相关配置
spring:
  # 应用配置
  application:
    # 应用名称：
    name: producer
  ###################################
  # mysql数据源配置
  datasource:
    # 数据库驱动
    driver-class-name: com.mysql.jdbc.Driver
    # 数据源名称
    name: defaultDataSource
    # 数据库连接地址
    url: jdbc:mysql://localhost:3306/day09?characterEncoding=utf-8&amp;useUnicode=true
    # 数据库用户名&amp;密码：
    username: root
    password: root

###################################
#dubbo相关配置
dubbo:
  application:
    name: xxx-service
  registry:
    address: zookeeper://192.168.25.128:2181
    timeout: 300000
  config-center:
    timeout: 300000
  scan:
    base-packages: com.m1sury.service.impl
</code></pre>
<blockquote>
<p>启动类</p>
</blockquote>
<pre><code class="language-java">@SpringBootApplication
@MapperScan(&quot;Mapper的具体包名&quot;)
public class ServiceApp {
    public static void main(String[] args) {
        SpringApplication.run(ServiceApp.class);
    }
}

</code></pre>
<h4 id="controller层">Controller层</h4>
<p><code>pom.xml</code></p>
<pre><code class="language-xml">&lt;dependencies&gt;
    &lt;!--web依赖启动器--&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.apache.dubbo&lt;/groupId&gt;
        &lt;artifactId&gt;dubbo-spring-boot-starter&lt;/artifactId&gt;
    &lt;/dependency&gt;
    &lt;!-- 简化zookeeper的API接口 --&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.apache.curator&lt;/groupId&gt;
        &lt;artifactId&gt;curator-framework&lt;/artifactId&gt;
        &lt;version&gt;2.12.0&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;!--thymeleaf模板依赖启动器--&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;
    &lt;/dependency&gt;
    &lt;!-- Service接口的依赖 --&gt;
&lt;/dependencies&gt;
</code></pre>
<p><code>application.yaml</code></p>
<pre><code class="language-yaml"># 应用服务 WEB 访问端口
server:
  port: 8001

###################################
# Spring相关配置
spring:
  # 应用配置
  application:
    # 应用名称：
    name: consumer
  ###################################
  # MVC相关配置
  mvc:
    # 开启时间格式转换
    date-format: yyyy-MM-dd HH:mm:ss
    # 放行静态资源
    static-path-pattern: /static/**
  ###################################
  # THYMELEAF相关配置
  thymeleaf:
    # 开启模板缓存（默认值： true ）
    cache: false
    # 检查模板是否存在，然后再呈现
    check-template: true
    # 检查模板位置是否正确（默认值 :true ）
    enabled: true
    # 模板编码
    encoding: UTF-8
    # 要运⽤于模板之上的模板模式。另⻅ StandardTemplate-ModeHandlers( 默认值： HTML5)
    mode: HTML5
###################################
#dubbo相关配置
dubbo:
  application:
    name: xxx-controller
  registry:
    address: zookeeper://192.168.25.128:2181
    timeout: 300000
  config-center:
    timeout: 300000
  scan:
    base-packages: com.m1sury.controller
</code></pre>
<blockquote>
<p>启动类</p>
</blockquote>
<pre><code class="language-java">@SpringBootApplication
public class WebApp {
    public static void main(String[] args) {
        SpringApplication.run(WebApp.class);
    }
}
</code></pre>
<hr>
<h3 id="springboot整合captcha">SpringBoot整合<a href="https://github.com/whvcse/EasyCaptcha">Captcha</a></h3>
<p><code>pom.xml</code></p>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;com.github.whvcse&lt;/groupId&gt;
    &lt;artifactId&gt;easy-captcha&lt;/artifactId&gt;
    &lt;version&gt;1.6.2&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<h3 id="springboot整合springsecurity">SpringBoot整合<a href="https://spring.io/projects/spring-security">SpringSecurity</a></h3>
<h4 id="spring-security简介">Spring-Security简介</h4>
<blockquote>
<p>起源</p>
</blockquote>
<p>Spring-Security实际上起源于Acegi Security,这个框架能为基于Spring的企业应用提供强大而灵活安全访问控制解决方案，并且这个框架充分利用了Spring的IoC和AOP功能，提供声明式安全访问控制的功能。后来，随着项目的发展，Acegi Security成为Spring官方子项目，后来被命名为&quot;Spring Security&quot;</p>
<blockquote>
<p>简单实现</p>
</blockquote>
<p>1、添加依赖</p>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt;
    &lt;version&gt;2.3.7.RELEASE&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<p>2、配置信息</p>
<pre><code class="language-yaml">spring:
  application:
    name: 01-security
  # 在内存中创建一个用户 用户名和密码都为admin
  security:
    user:
      name: admin
      password: admin
</code></pre>
<p>3、添加依赖之后启动项目访问页面就会有默认的登录页面</p>
<blockquote>
<p>实现自定义逻辑</p>
</blockquote>
<p>如果需要实现自定义逻辑，需要实现<code>UserDetailService</code>接口</p>
<figure data-type="image" tabindex="16"><img src="https://gitee.com/a1021809072/mypic/raw/master/img/image-20210524235710745.png" alt="image-20210524235710745" loading="lazy"></figure>
<p>返回值UserDetails是一个接口,可以使用实现类User</p>
<pre><code class="language-java">public interface UserDetails extends Serializable {
		Collection&lt;? extends GrantedAuthority&gt; getAuthorities();//获取所有权限

    	String getPassword();//获取密码

    	String getUsername();//获取用户名

    	boolean isAccountNonExpired();//账号是否过期

    	boolean isAccountNonLocked();//账号是否被锁定

    	boolean isCredentialsNonExpired();//密码是否过期

    	boolean isEnabled();//是否可用
}
</code></pre>
<hr>
<h3 id="springboot整合shiro框架todo">SpringBoot整合Shiro框架(TODO)</h3>
<h4 id="shiro框架的简介">Shiro框架的简介</h4>
<p>Apache Shiro是Java的一个安全框架，使用Shiro的人越来越多，因为Shiro相对于Spring Security更简单，可能没有Spring Security功能强大。</p>
<p>Shiro的基本功能点：认证、授权、会话管理、加密、与Web集成、缓存等</p>
<figure data-type="image" tabindex="17"><img src="https://gitee.com/a1021809072/mypic/raw/master/img/d59f6d02-1f45-3285-8983-4ea5f18111d5.png" alt="img" loading="lazy"></figure>
<p><strong>Authentication:</strong> 身份认证/登录,验证 用户是否拥有相应的身份</p>
<p>**Authorization:**授权，即权限验证，验证某个已认证的用户是否拥有某个权限；即判断用户是否能做某件事情</p>
<p>**Session Manager:**会话管理，即用户登录后就是一次会话，在没有退出之前，它的所有信息都在会话中，会话可以是普通JavaSe环境，也可以是Web环境的</p>
<p>**Cryptography:**加密，保护数据的安全性</p>
<h4 id="shiro的主要架构">Shiro的主要架构</h4>
<figure data-type="image" tabindex="18"><img src="https://gitee.com/a1021809072/mypic/raw/master/img/9b959a65-799d-396e-b5f5-b4fcfe88f53c.png" alt="img" loading="lazy"></figure>
<ul>
<li><strong>Subject：<strong>主体，即可以代表用户，也可以代表程序(网络爬虫等),系统则需要对其进行认证和授权，可以看到主体是任何可以与应用交互的</strong>用户</strong></li>
<li>**SecurityManager：**安全管理，用户请求URL，对应一个Subject对象，由SecurityManager统一对Subject进行认证和授权</li>
<li><strong>Authenricator：<strong>认证器，主要对Subject进行认证，Subject的信息在Shiro中是通过</strong>Authentication Token</strong>对象来存储，由<strong>AuthenricationStrategy</strong>进行验证管理。如果觉得Shiro默认的不好，可以自定义实现</li>
<li>**Authorizer：**授权器，Subject认证后，由它来对其授予对应角色权限，即控制着用户能访问应用中的哪些功能</li>
<li>**SessionManager：**Shiro的Session管理方式，Shiro提供了一个专门管理Session的方式</li>
<li>**Realm：**域，Shiro从Realm获取安全数据(如用户、角色、权限),SecurityManager要验证用户身份，它需要从Realm获取相应的用户进行比较以确定用户身份是否合法，也需要从Realm得到用户相应的角色/权限进行验证用户是否能进行操作；可以把Realm看成DataSource，即安全数据源</li>
</ul>
<h4 id="身份认证流程">身份认证流程</h4>
<figure data-type="image" tabindex="19"><img src="https://gitee.com/a1021809072/mypic/raw/master/img/8d639160-cd3e-3b9c-8dd6-c7f9221827a5.png" alt="img" loading="lazy"></figure>
<pre><code class="language-java">/*
	具体流程如下:
	
	1.首先调用Subject.login(token)进行登录,其会自动委托给SecurityManager，调用之前必须通过 SecurityUtils.setSecurityManager()进行设置
	2.SecurityManager负责真正的身份验证逻辑,它会交给Authenticator进行身份验证
	3.Authenticator才是真正的身份验证者,ShiroAPI中核心的身份认证入口点,此处可以自定义自己的实现
	4.Authenticator可能会委托给相应的AuthenticationStrategy进行多Realm身份验证，默认ModularRealmAuthenticator会调用AuthenticationStrategy进行多Realm身份验证
	5、Authenticator会把相应的token传入Realm，从Realm获取身份验证信息，如果没有返回/抛出异常表示身份验证失败了。此处可以配置多个Realm，将按照相应的顺序及策略进行访问
*/
</code></pre>
<h4 id="realm">Realm</h4>
<blockquote>
<p>以下是实现Realm接口需要实现的四个方法的具体解释</p>
</blockquote>
<pre><code class="language-java">String getName(); //返回一个唯一的Realm名字  
boolean supports(AuthenticationToken token); //判断此Realm是否支持此Token  
AuthenticationInfo getAuthenticationInfo(AuthenticationToken token)  
 throws AuthenticationException;  //根据Token获取认证信息  
</code></pre>
<blockquote>
<p>自定义Realm实现</p>
</blockquote>
<p>1、首先创建自定义的配置文件</p>
<p><code>shiro-realm.ini</code></p>
<pre><code class="language-ini"># 声明一个realm
myrealm1=具体的自定义Realm类的全类名
# 指定SecurityManager的Realm实现
# 通过$name 来引用之前的Realm定义
securityManager.realms=$myrealm1


############################
# 多Realm配置
# 声明Realm
myrealm1=具体的自定义Realm类的全类名
myrealm2=具体的自定义Realm类的全类名
#指定securityManager的realms实现  
securityManager.realms=$myRealm1,$myRealm2 
</code></pre>
<p><code>MyRealm1.java</code></p>
<pre><code class="language-java">public class MyRealm1 implements Realm {  
    @Override  
    public String getName() {  
        return &quot;myrealm1&quot;;  
    }  
    @Override  
    public boolean supports(AuthenticationToken token) {  
        //仅支持UsernamePasswordToken类型的Token  
        return token instanceof UsernamePasswordToken;   
    }  
    @Override  
    public AuthenticationInfo getAuthenticationInfo(AuthenticationToken token) throws AuthenticationException {  
        String  username = (String) token.getPrincipal();//得到用户名
        char[] s = (char[]) token.getCredentials();
        String password = s.toString();//得到密码
        if(!&quot;m1sury&quot;.equals(username)) {  
            throw new UnknownAccountException(); //如果用户名错误  
        }  
        if(!&quot;123&quot;.equals(password)) {  
            throw new IncorrectCredentialsException(); //如果密码错误  
        }  
        //如果身份认证验证成功，将用户名和密码还有Realm的名称传入,返回认证信息
        //此信息中包含了身份及凭证；如果验证失败将抛出相应的AuthenticationException实现。
        return new SimpleAuthenticationInfo(username, password, getName());  
    }  
} 
</code></pre>
<h4 id="授权">授权</h4>
<blockquote>
<p>授权也叫访问控制，即在应用中控制谁能访问哪些资源，在授权中的几个关键对象：主体(subject)、资源(resource)、权限(permission)、角色(role)</p>
</blockquote>
<ul>
<li><strong>主体</strong>：即访问应用的用户，在Shiro中使用Subject代表该用户。用户只有授权后才允许访问相应的资源</li>
<li><strong>资源</strong>：在应用中用户可以访问的东西，用户只有授权才能访问</li>
<li><strong>权限</strong>：安全策略中的原子授权单位，通过授权可以表示在应用中用户有没有操作某个资源的权力</li>
<li><strong>角色</strong>：角色代表了操作集合，一般情况下赋予用户角色而不是权限，即这样用户可以拥有一组权限，赋予权限时比较方便</li>
</ul>
<pre><code class="language-ini">[users]
zhang=123,role1,role2
#  规则是 用户名=密码,角色1,角色2  

[roles]
#  规则是 角色=权限1,权限2
role1=user:create,user:update
role2=user:create,user:delete

# 用户拥有所有权限可以简写成*
</code></pre>
<hr>
<h3 id="swagger">Swagger</h3>
<blockquote>
<p>依赖</p>
</blockquote>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;io.springfox&lt;/groupId&gt;
    &lt;artifactId&gt;springfox-boot-starter&lt;/artifactId&gt;
    &lt;version&gt;3.0.0&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<blockquote>
<p>Swagger的bean实例</p>
</blockquote>
<pre><code class="language-java">package com.m1sury.config;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.core.env.Environment;
import org.springframework.core.env.Profiles;
import springfox.documentation.builders.PathSelectors;
import springfox.documentation.builders.RequestHandlerSelectors;
import springfox.documentation.service.ApiInfo;
import springfox.documentation.service.Contact;
import springfox.documentation.spi.DocumentationType;
import springfox.documentation.spring.web.plugins.Docket;
import springfox.documentation.swagger2.annotations.EnableSwagger2;

import java.util.ArrayList;

import static springfox.documentation.service.ApiInfo.DEFAULT_CONTACT;

@Configuration
@EnableSwagger2 //开启Swagger2
public class SwaggerConfig {
    //配置Swagger的Docket的bean实例
    @Bean
    public Docket docket(Environment environment){
        Profiles profiles = Profiles.of(&quot;dev&quot;);
        //获取项目的环境
        //通过environment.acceptsProfiles判断是否处在自己设定的环境当中
        boolean flag = environment.acceptsProfiles(profiles);
        return new Docket(DocumentationType.SWAGGER_2)
                .apiInfo(apiInfo())
                //enable: 是否启动swagger,false表示Swagger不能在浏览器中访问
                .enable(flag)
                .select()
                //RequestHandlerSelectors:配置要扫描接口的方式
                //basePackage:指定要扫描的包
                //any():扫描全部
                //none():不扫描
                //withClassAnnotation:扫描类上的注解
                .apis(RequestHandlerSelectors.basePackage(&quot;com.m1sury.controller&quot;))
                //paths(): 过滤什么路径
                //.paths(PathSelectors.ant(&quot;/m1sury/**&quot;))
                .build();
    }

    //配置Swagger
    private ApiInfo apiInfo(){
        //作者信息
        Contact contact = new Contact(&quot;m1sury&quot;,&quot;www.com.com&quot;,&quot;a1021809072@gmail.com&quot;);
        return new ApiInfo(&quot;SwaggerAPI文档&quot;,
                &quot;这是一个描述&quot;,
                &quot;1.0&quot;,
                &quot;urn:tos&quot;,
                contact,
                &quot;Apache 2.0&quot;,
                &quot;http://www.apache.org/licenses/LICENSE-2.0&quot;,
                new ArrayList());
    }
}
</code></pre>
<blockquote>
<p>访问http://localhost:8080/swagger-ui/index.html即可测试</p>
</blockquote>
<figure data-type="image" tabindex="20"><img src="https://gitee.com/a1021809072/mypic/raw/master/img/image-20210213142622905.png" alt="image-20210213142622905" loading="lazy"></figure>
<h3 id="错误案例">错误案例</h3>
<h4 id="首个错误案例"><strong>首个错误案例</strong></h4>
<pre><code class="language-java">### The error may exist in file [E:\bigbaseworkspase\demo\target\classes\mapper\StuMapper.xml]
### The error may involve com.m1sury.dao.StuDao.findAll
### The error occurred while executing a query
### Cause: org.springframework.jdbc.CannotGetJdbcConnectionException: Failed to obtain JDBC Connection; nested exception is com.mysql.cj.jdbc.exceptions.CommunicationsException: Communications link failure

The last packet sent successfully to the server was 0 milliseconds ago. The driver has not received any packets from the server.] with root cause

java.net.UnknownHostException: locahost
</code></pre>
<pre><code class="language-yml">spring:
  datasource:
    url: jdbc:mysql://locahost:3306/exe   # localhost单词不对,(lll￢ω￢)汗
    username: root
    password: 123
    driver-class-name: com.mysql.cj.jdbc.Driver
mybatis:
  mapper-locations: classpath:mapper/*.xml
  type-aliases-package: com.m1sury.bean
</code></pre>
<h4 id="no2-error">No.2 Error</h4>
<pre><code class="language-java">org.thymeleaf.exceptions.TemplateInputException: Error resolving template [book/findBookInfo],
template might not exist or might not be accessible by any of the configured Template Resolvers
</code></pre>
<pre><code class="language-java">//解决方式是在报错的请求方法上加上@ResponseBody注解就可以解决
</code></pre>
<h4 id="前端error">前端Error</h4>
<pre><code class="language-javascript">var val = $(this).val();

Uncaught TypeError: Cannot read property 'toLowerCase' of undefined
</code></pre>
<pre><code class="language-shell"># 问题: this已经获取不到当前所指的对象,所以报错
# 解决方法
# 重新获取对象
</code></pre>
<h4 id="前端资源引入失败">前端资源引入失败</h4>
<p><strong>如果出现引入失败的错误,清空项目,重新构建项目</strong></p>
<h4 id="jpa-error">JPA Error</h4>
<pre><code class="language-java">org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'entityManagerFactory' defined in class path resource [org/springframework/boot/autoconfigure/orm/jpa/HibernateJpaConfiguration.class]: Invocation of init method failed; nested exception is javax.persistence.PersistenceException: [PersistenceUnit: default] Unable to build Hibernate SessionFactory; nested exception is org.hibernate.MappingException: Repeated column in mapping for entity: com.m1sury.dto.Student column: cid (should be mapped with insert=&quot;false&quot; update=&quot;false&quot;)
    
    
    
// 错误原因：在映射文件中重复映射了表中的同一个字段
@Entity(name = &quot;s_stu&quot;)
@Data
@AllArgsConstructor
@NoArgsConstructor
@ToString
public class Student {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Integer sid;
    private String sname;
    private String sbirth;
    private Integer status;
    private Integer cid;   //重复映射了cls表中的同一个字段
    @JoinColumn(name = &quot;cid&quot;)
    @ManyToOne
    private Clazz clazz;   //这里也包含了cid字段,所以报错
}

</code></pre>
<h4 id="mybatis-error">Mybatis Error</h4>
<pre><code class="language-java">org.apache.ibatis.ognl.OgnlException: source is null for getProperty(null, &quot;sname&quot;)
</code></pre>
<pre><code class="language-bash"># 方法的返回值是mybatis映射文件resultType是map,调用的方法返回值是List&lt;Map&gt;
&lt;where&gt;
    &lt;!--&lt;if test=&quot;map!=null&quot;&gt;--&gt;
    &lt;if test=&quot;map.sname!=null and map.sname!=''&quot;&gt;
    and s_stu.sname like concat('%',#{map.sname},'%')
    &lt;/if&gt;
    &lt;if test=&quot;map.startTime!=null and map.startTime!=''&quot;&gt;
    and s_stu.sbirth&amp;gt;=#{map.startTime}
    &lt;/if&gt;
    &lt;if test=&quot;map.endTime!=null and map.endTime!=''&quot;&gt;
    and s_stu.sbirth&amp;lt;=#{map.endTime}
    &lt;/if&gt;
    &lt;!--&lt;/if&gt;--&gt;
&lt;/where&gt;
# 报错的原因：
# 版本低的mybatis可以如上方一样直接判断map.sname是否为null,版本高的mybatis就需要先去判断对象是否为null才可以判断里面属性是否为空
# 因为map也是个对象，也可能为Null,所以不判断的话会报source is null for getProperty(null, “sname”)异常
</code></pre>
<h4 id="springboot整合mybatis-plus-error">SpringBoot整合Mybatis-plus Error</h4>
<figure data-type="image" tabindex="21"><img src="C:%5CUsers%5CASUS%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210429162947573.png" alt="image-20210429162947573" loading="lazy"></figure>
<p>原因：mybatis-plus依赖包找不到这个方法，由于版本兼容问题</p>
<p>解决办法：更换mybatis-plus的版本</p>
<blockquote>
<p>2.SpringBoot整合mybatis-plus</p>
</blockquote>
<p><code>mybatis-plus</code>和``pagehelper`依赖冲突,</p>
<p>原因：pageHelper依赖中也会导入mybatis-spring-boot-starter,导致依赖冲突</p>
<p>解决方法：排除<code>mybatis</code>和<code>mybatis-spring</code></p>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt;
    &lt;artifactId&gt;pagehelper-spring-boot-starter&lt;/artifactId&gt;
    &lt;version&gt;1.2.10&lt;/version&gt;
    &lt;exclusions&gt;
        &lt;exclusion&gt;
            &lt;groupId&gt;org.mybatis&lt;/groupId&gt;
            &lt;artifactId&gt;mybatis&lt;/artifactId&gt;
        &lt;/exclusion&gt;
        &lt;exclusion&gt;
            &lt;groupId&gt;org.mybatis&lt;/groupId&gt;
            &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt;
        &lt;/exclusion&gt;
    &lt;/exclusions&gt;
&lt;/dependency&gt;
</code></pre>
<figure data-type="image" tabindex="22"><img src="C:%5CUsers%5CASUS%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210429201559905.png" alt="image-20210429201559905" loading="lazy"></figure>
<h4 id="整合elasticsearch的错误">整合ElasticSearch的错误</h4>
<figure data-type="image" tabindex="23"><img src="C:/Users/ASUS/AppData/Roaming/Typora/typora-user-images/image-20210506210038840.png" alt="image-20210506210038840" loading="lazy"></figure>
<blockquote>
<p>解决方法</p>
</blockquote>
<p>把PageRequest改为Pageable</p>
<h4 id="maven项目编译找不到符号">Maven项目编译找不到符号</h4>
<blockquote>
<p>解决方法</p>
</blockquote>
<p>1、将Setting里的<code>Editor--&gt;File Encodings</code>的三个编码设置为<code>UTF-8</code></p>
<p>2、Settings的<code>Build,Execution,Deployment--&gt;Compiler--&gt;Java Compiler</code>的<code>Project bytecode version</code>和各个模块的JDK编译版本都设置为1.8</p>
<p>3、聚合项目，父项目clean，然后package</p>
<h3 id="难点">难点</h3>
<h4 id="登录拦截器">登录拦截器</h4>
<blockquote>
<p>流程</p>
</blockquote>
<p>1、编写实现<code>HandlerInterceptor</code>接口的自定义拦截器</p>
<p>2、通过配置类注册拦截器</p>
<p>3、配置自定义的拦截路径，以及去除对指定路径和静态资源的拦截</p>
<p><code>LoginConfig.java</code></p>
<pre><code class="language-java">package com.m1sury.config;

import com.m1sury.dto.Student;
import org.springframework.stereotype.Component;
import org.springframework.web.servlet.HandlerInterceptor;
import org.springframework.web.servlet.ModelAndView;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.http.HttpSession;
import java.io.IOException;

@Component
public class LoginConfig implements HandlerInterceptor {
    //这个方法是访问前执行的,需要在这里写验证登录状态的业务逻辑
    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
        //将登录的对象存入Session的作用域中,将对象从Session中取出,如果对象不为空
        //并且可以从数据库中查出,说明登录成功,可放行
        //true表示可放行,false表示不放行
        Student stu=(Student) request.getSession().getAttribute(&quot;stu&quot;);
        if(stu!=null){
            return true;
        }
        //对象不存在,需要跳转到登录页面
        response.sendRedirect(request.getContextPath()+&quot;/toIndex&quot;);
        return false;//如果设置为false时，被请求时，拦截器执行到此处将不会继续操作
        //如果设置为true时，请求将会继续执行后面的操作
    }

    @Override
    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception {
        System.out.println(&quot;postHandler方法&quot;);
    }

    @Override
    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception {
        System.out.println(&quot;afterCompletion方法&quot;);
    }
}
</code></pre>
<p><code>WebConfigurer.java</code></p>
<h5 id="重点对静态资源的过滤"><strong>重点：对静态资源的过滤</strong></h5>
<p><font color=red>取消对登录请求的拦截</font></p>
<pre><code class="language-java">package com.m1sury.config;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.servlet.config.annotation.InterceptorRegistry;
import org.springframework.web.servlet.config.annotation.ResourceHandlerRegistry;
import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;
import sun.rmi.runtime.Log;
//标明这是一个配置类
@Configuration
public class WebConfigurer implements WebMvcConfigurer {
    @Autowired
    LoginConfig loginConfig;

    //本方法用来注册拦截器,写好的组件需要通过注册才能生效
    @Override
    public void addInterceptors(InterceptorRegistry registry) {
  	//需要放行到达登陆页面的请求和登录的请求,其他请求自定义
	        registry.addInterceptor(loginConfig).addPathPatterns(&quot;/**&quot;).excludePathPatterns(&quot;/toIndex&quot;,&quot;/static/**&quot;,&quot;/login&quot;);
    }
}
</code></pre>
<h4 id="图片上传">图片上传</h4>
<pre><code class="language-html">&lt;!--基于AngularJS前端--&gt;
&lt;html&gt;
    &lt;head&gt;
        &lt;script src=&quot;js/angular.min.js&quot;&gt;&lt;/script&gt;
        &lt;script&gt;
        	var app=angular.module('pinyougou',[]);
            app.controller('a', function ($scope, $http) {
                $scope.upload=function () {
                    //js原生语法获取logo的文件域
                var file= document.getElementById(&quot;logo&quot;).files;
                //使用formdata传输图片
                var formdata = new FormData();
                formdata.append(&quot;file&quot;,file[0]);
                $http({
                    method:&quot;POST&quot;,
                    url:&quot;/upload&quot;,
                    data:formdata,
                    //Content-Type设置为undefined,浏览器会自动设置为multipart/form-data
                    headers:{&quot;Content-Type&quot;:undefined},
                    //通过设置 transformRequest: angular.identity ，anjularjs transformRequest function 将序列化我们的formdata object.
                    transformRequest:angular.identity
                })
            }
            }
        &lt;/script&gt;
    &lt;/head&gt;
    &lt;body ng-app=&quot;pinyougou&quot;  ng-controller=&quot;a&quot;&gt;
       头像:&lt;input type=&quot;file&quot; id=&quot;logo&quot; ng-change=&quot;upload()&quot; ng-model=&quot;entity.logo&quot;&gt;&lt;br&gt; 
    &lt;/body&gt;
&lt;/html&gt;
</code></pre>

              </div>
              <div class="toc-container">
                <ul class="markdownIt-TOC">
<li>
<ul>
<li><a href="#springboot">SpringBoot</a>
<ul>
<li><a href="#%E4%BB%80%E4%B9%88%E6%98%AFspring">什么是Spring</a>
<ul>
<li><a href="#spring%E5%A6%82%E4%BD%95%E7%AE%80%E5%8C%96%E5%BC%80%E5%8F%91">Spring如何简化开发</a></li>
</ul>
</li>
<li><a href="#%E4%BB%80%E4%B9%88%E6%98%AFspringboot">什么是SpringBoot</a><br>
*
<ul>
<li><a href="#springboot%E7%9A%84%E4%BC%98%E7%82%B9">SpringBoot的优点</a></li>
<li><a href="#%E7%AC%AC%E4%B8%80%E4%B8%AAspringboot%E7%A8%8B%E5%BA%8Fidea%E7%89%88%E6%9C%AC20203">第一个SpringBoot程序(idea版本2020.3)</a>
<ul>
<li><a href="#font-colorred%E4%B8%BA%E4%BB%80%E4%B9%88springboot%E4%B8%ADcontroller%E4%BB%A5%E5%8F%8A%E5%85%B6%E4%BB%96%E5%B1%82%E8%A6%81%E4%B8%8Eapplication%E7%B1%BB%E5%9C%A8%E5%90%8C%E7%BA%A7%E7%9B%AE%E5%BD%95%E4%B8%8Bfont"><font color=red>为什么SpringBoot中controller以及其他层要与Application类在同级目录下</font></a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E5%BA%95%E5%B1%82%E6%B3%A8%E8%A7%A3">底层注解</a></li>
<li><a href="#%E5%8E%9F%E7%90%86%E5%88%9D%E6%8E%A2">原理初探</a></li>
<li><a href="#%E8%87%AA%E5%8A%A8%E5%8C%96%E9%85%8D%E7%BD%AE">自动化配置</a></li>
<li><a href="#%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6">配置文件</a>
<ul>
<li><a href="#%E5%9F%BA%E6%9C%AC%E4%BE%9D%E8%B5%96">基本依赖</a></li>
<li><a href="#%E9%80%9A%E8%BF%87yaml%E8%BF%9B%E8%A1%8C%E8%B5%8B%E5%80%BC">通过YAML进行赋值</a></li>
<li><a href="#%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E7%9A%84%E4%BC%98%E5%85%88%E7%BA%A7">配置文件的优先级</a></li>
<li><a href="#springboot%E5%A4%9A%E7%8E%AF%E5%A2%83%E4%B8%8B%E7%9A%84%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6">SpringBoot多环境下的配置文件</a>
<ul>
<li><a href="#1-%E9%80%9A%E8%BF%87properties%E6%96%87%E4%BB%B6">1、通过properties文件</a></li>
<li><a href="#2-%E9%80%9A%E8%BF%87yaml%E6%96%87%E4%BB%B6">2、通过YAML文件</a></li>
</ul>
</li>
<li><a href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5">数据库连接</a></li>
</ul>
</li>
<li><a href="#springboot-2">SpringBoot</a></li>
<li><a href="#web%E5%BC%80%E5%8F%91">Web开发</a>
<ul>
<li><a href="#%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90">静态资源</a></li>
<li><a href="#%E9%A6%96%E9%A1%B5">首页</a>
<ul>
<li><a href="#%E7%BD%91%E9%A1%B5%E5%9B%BE%E6%A0%87">网页图标</a></li>
<li><a href="#%E9%A6%96%E9%A1%B5%E7%9A%84%E9%85%8D%E7%BD%AE">首页的配置</a></li>
<li><a href="#springmvc%E6%89%A9%E5%B1%95">springmvc扩展</a></li>
</ul>
</li>
<li><a href="#%E8%AF%B7%E6%B1%82%E5%8F%82%E6%95%B0%E5%A4%84%E7%90%86">请求参数处理</a></li>
</ul>
</li>
<li><a href="#%E6%95%B4%E5%90%88jsp">整合jsp</a>
<ul>
<li><a href="#applicationyml">application.yml</a></li>
<li><a href="#webapp%E6%96%87%E4%BB%B6%E5%A4%B9%E7%9A%84%E5%88%9B%E5%BB%BA">webapp文件夹的创建</a></li>
</ul>
</li>
<li><a href="#springboot%E6%95%B4%E5%90%88thymeleaf">SpringBoot整合Thymeleaf</a><br>
*
<ul>
<li><a href="#%E6%A8%A1%E6%9D%BF%E5%BC%95%E6%93%8E">模板引擎</a></li>
<li><a href="#%E7%AE%80%E5%8D%95%E7%9A%84%E8%A1%A8%E8%BE%BE%E5%BC%8F">简单的表达式</a></li>
</ul>
</li>
<li><a href="#freemarkertodo">FreeMarker(TODO)</a></li>
<li><a href="#springboot%E6%95%B4%E5%90%88jsp">SpringBoot整合JSP</a></li>
<li><a href="#springboot%E6%95%B4%E5%90%88mybatis">SpringBoot整合Mybatis</a></li>
<li><a href="#springboot%E6%95%B4%E5%90%88jpa">SpringBoot整合JPA</a>
<ul>
<li><a href="#%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3">常用注解</a></li>
<li><a href="#%E5%9F%BA%E6%9C%AC%E6%B5%81%E7%A8%8B">基本流程</a></li>
</ul>
</li>
<li><a href="#springboot%E6%95%B4%E5%90%88redis">SpringBoot整合Redis</a></li>
<li><a href="#springboot%E4%B8%AD%E4%BD%BF%E7%94%A8%E5%AE%9A%E6%97%B6%E5%99%A8">SpringBoot中使用定时器</a></li>
<li><a href="#springboot-%E9%82%AE%E4%BB%B6%E5%8F%91%E9%80%81">SpringBoot 邮件发送</a></li>
<li><a href="#springboot%E6%95%B4%E5%90%88activemq">SpringBoot整合ActiveMQ</a>
<ul>
<li><a href="#mq%E6%A6%82%E8%BF%B0">MQ概述</a></li>
<li><a href="#mq%E7%9A%84%E7%BC%BA%E7%82%B9">MQ的缺点</a></li>
<li><a href="#java%E6%93%8D%E4%BD%9Cactivemq">Java操作activeMQ</a></li>
</ul>
</li>
<li><a href="#springboot%E6%95%B4%E5%90%88rabbitmq">SpringBoot整合RabbitMQ</a></li>
<li><a href="#springboot%E5%8F%91%E9%80%81%E7%9F%AD%E4%BF%A1">SpringBoot发送短信</a>
<ul>
<li><a href="#%E5%9F%BA%E6%9C%AC%E7%9A%84%E6%B5%81%E7%A8%8B">基本的流程</a></li>
</ul>
</li>
<li><a href="#%E6%9F%A5%E8%AF%A2ip%E5%9C%B0%E5%9D%80js%E5%AE%9E%E7%8E%B0">查询IP地址(JS实现)</a></li>
<li><a href="#springboot%E9%A1%B5%E9%9D%A2%E9%9B%86%E6%88%90ckeditor4">SpringBoot页面集成CKeditor4</a></li>
<li><a href="#springboot%E6%95%B4%E5%90%88fastdfs">SpringBoot整合FastDFS</a></li>
<li><a href="#springboot%E6%95%B4%E5%90%88elasticsearchtodo">SpringBoot整合ElasticSearch(TODO)</a></li>
<li><a href="#springboot%E6%95%B4%E5%90%88dubbotodo">SpringBoot整合Dubbo(TODO)</a>
<ul>
<li><a href="#%E5%AE%9E%E4%BD%93%E7%B1%BB%E5%8F%AF%E4%BB%A5%E5%BF%BD%E7%95%A5">实体类(可以忽略)</a></li>
<li><a href="#%E6%95%B0%E6%8D%AE%E8%AE%BF%E9%97%AE%E5%B1%82dao">数据访问层(DAO)</a></li>
<li><a href="#service%E5%AE%9E%E7%8E%B0%E5%B1%82service%E6%8E%A5%E5%8F%A3%E7%BB%A7%E6%89%BF%E5%AE%9E%E4%BD%93%E7%B1%BB%E4%BE%9D%E8%B5%96%E5%8D%B3%E5%8F%AF">Service实现层,Service接口继承实体类依赖即可</a></li>
<li><a href="#controller%E5%B1%82">Controller层</a></li>
</ul>
</li>
<li><a href="#springboot%E6%95%B4%E5%90%88captcha">SpringBoot整合Captcha</a></li>
<li><a href="#springboot%E6%95%B4%E5%90%88springsecurity">SpringBoot整合SpringSecurity</a>
<ul>
<li><a href="#spring-security%E7%AE%80%E4%BB%8B">Spring-Security简介</a></li>
</ul>
</li>
<li><a href="#springboot%E6%95%B4%E5%90%88shiro%E6%A1%86%E6%9E%B6todo">SpringBoot整合Shiro框架(TODO)</a>
<ul>
<li><a href="#shiro%E6%A1%86%E6%9E%B6%E7%9A%84%E7%AE%80%E4%BB%8B">Shiro框架的简介</a></li>
<li><a href="#shiro%E7%9A%84%E4%B8%BB%E8%A6%81%E6%9E%B6%E6%9E%84">Shiro的主要架构</a></li>
<li><a href="#%E8%BA%AB%E4%BB%BD%E8%AE%A4%E8%AF%81%E6%B5%81%E7%A8%8B">身份认证流程</a></li>
<li><a href="#realm">Realm</a></li>
<li><a href="#%E6%8E%88%E6%9D%83">授权</a></li>
</ul>
</li>
<li><a href="#swagger">Swagger</a></li>
<li><a href="#%E9%94%99%E8%AF%AF%E6%A1%88%E4%BE%8B">错误案例</a>
<ul>
<li><a href="#%E9%A6%96%E4%B8%AA%E9%94%99%E8%AF%AF%E6%A1%88%E4%BE%8B"><strong>首个错误案例</strong></a></li>
<li><a href="#no2-error">No.2 Error</a></li>
<li><a href="#%E5%89%8D%E7%AB%AFerror">前端Error</a></li>
<li><a href="#%E5%89%8D%E7%AB%AF%E8%B5%84%E6%BA%90%E5%BC%95%E5%85%A5%E5%A4%B1%E8%B4%A5">前端资源引入失败</a></li>
<li><a href="#jpa-error">JPA Error</a></li>
<li><a href="#mybatis-error">Mybatis Error</a></li>
<li><a href="#springboot%E6%95%B4%E5%90%88mybatis-plus-error">SpringBoot整合Mybatis-plus Error</a></li>
<li><a href="#%E6%95%B4%E5%90%88elasticsearch%E7%9A%84%E9%94%99%E8%AF%AF">整合ElasticSearch的错误</a></li>
<li><a href="#maven%E9%A1%B9%E7%9B%AE%E7%BC%96%E8%AF%91%E6%89%BE%E4%B8%8D%E5%88%B0%E7%AC%A6%E5%8F%B7">Maven项目编译找不到符号</a></li>
</ul>
</li>
<li><a href="#%E9%9A%BE%E7%82%B9">难点</a>
<ul>
<li><a href="#%E7%99%BB%E5%BD%95%E6%8B%A6%E6%88%AA%E5%99%A8">登录拦截器</a>
<ul>
<li><a href="#%E9%87%8D%E7%82%B9%E5%AF%B9%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%E7%9A%84%E8%BF%87%E6%BB%A4"><strong>重点：对静态资源的过滤</strong></a></li>
</ul>
</li>
<li><a href="#%E5%9B%BE%E7%89%87%E4%B8%8A%E4%BC%A0">图片上传</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>

              </div>
            </div>
          </article>
        </div>

        

        

        <div class="site-footer">
  Powered by <a href="www.a1021809072@gmail.com" target="_blank">MyGoogleEmail</a>
  <a class="rss" href="https://m1sury.github.io/atom.xml" target="_blank">
    <i class="ri-rss-line"></i> RSS
  </a>
</div>

      </div>
    </div>

    <script>
      hljs.initHighlightingOnLoad()

      let mainNavLinks = document.querySelectorAll(".markdownIt-TOC a");

      // This should probably be throttled.
      // Especially because it triggers during smooth scrolling.
      // https://lodash.com/docs/4.17.10#throttle
      // You could do like...
      // window.addEventListener("scroll", () => {
      //    _.throttle(doThatStuff, 100);
      // });
      // Only not doing it here to keep this Pen dependency-free.

      window.addEventListener("scroll", event => {
        let fromTop = window.scrollY;

        mainNavLinks.forEach((link, index) => {
          let section = document.getElementById(decodeURI(link.hash).substring(1));
          let nextSection = null
          if (mainNavLinks[index + 1]) {
            nextSection = document.getElementById(decodeURI(mainNavLinks[index + 1].hash).substring(1));
          }
          if (section.offsetTop <= fromTop) {
            if (nextSection) {
              if (nextSection.offsetTop > fromTop) {
                link.classList.add("current");
              } else {
                link.classList.remove("current");    
              }
            } else {
              link.classList.add("current");
            }
          } else {
            link.classList.remove("current");
          }
        });
      });

    </script>
  </body>
</html>
